From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Fri, 10 Jun 2022 00:26:10 +0200
Subject: [PATCH] Per-player load, see and track view distance


diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 8aa45702f3033c2d5375e8eca1450b935b93b352..7db5fa07eaa4bb0c08d3f5bb930b303837fefa2d 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -166,8 +166,11 @@ public class TimingsExport extends Thread {
                 })),
                 // Paper start - replace chunk loader system
                 pair("ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()),
-                pair("no-ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()),
-                pair("sending-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())
+                // Suki start - per-player track and see view distance
+                pair("max-track-distance", world.sukiConfig().viewDistance.track.getMax()),
+                pair("max-see-distance", world.sukiConfig().viewDistance.see.getMax()),
+                pair("max-load-distance", world.sukiConfig().viewDistance.load.getMax())
+                // Suki end - per-player track and see view distance
                 // Paper end - replace chunk loader system
             ));
         }));
diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index fe79c0add4f7cb18d487c5bb9415c40c5b551ea2..dda0f831d0e3768f5798705695742d0c9052f963 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -44,6 +44,28 @@ public class WorldTimingsHandler {
     public final Timing broadcastChunkUpdates;
     public final Timing countNaturalMobs;
 
+    // Suki start - per-player view distance
+//    public final Timing getPlayersNearChunkForSending;
+    public final Timing chunkMapPlayerMove;
+//    public final Timing chunkMapPlayerMoveUpdatePos;
+//    public final Timing chunkMapPlayerMoveUpdateDistanceManager;
+//    public final Timing chunkMapPlayerMoveUpdatePlayerMap;
+//    public final Timing chunkMapUpdatePlayerMaps;
+    public final Timing playerChunkLoaderUpdate;
+    public final Timing playerChunkLoaderUpdateGetViewDistances;
+    public final Timing playerChunkLoaderUpdateDecideWhetherToRecalculate;
+//    public final Timing chunkMapPlayerMoveUpdateChunkTrackingOrSeeing;
+//    public final Timing chunkMapPlayerMoveSortChunksForTrackAndSee;
+    public final Timing computeTrackViewDistance;
+    public final Timing computeSeeViewDistance;
+    public final Timing computeLoadViewDistance;
+    public final Timing trackViewDistanceMayHaveChanged;
+    public final Timing seeViewDistanceMayHaveChanged;
+    public final Timing loadViewDistanceMayHaveChanged;
+    public final Timing processTrackViewDistanceChange;
+    public final Timing processSeeViewDistanceChange;
+    // Suki end - per-player view distance
+
     public final Timing chunkLoad;
     public final Timing chunkLoadPopulate;
     public final Timing syncChunkLoad;
@@ -119,6 +141,27 @@ public class WorldTimingsHandler {
         broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
         countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
 
+        // Suki start - per-player view distance
+//        getPlayersNearChunkForSending = Timings.ofSafe("Get players near chunk for sending");
+        chunkMapPlayerMove = Timings.ofSafe("Chunk map player move");
+//        chunkMapPlayerMoveUpdatePos = Timings.ofSafe("Chunk map player move - update pos");
+//        chunkMapPlayerMoveUpdateDistanceManager = Timings.ofSafe("Chunk map player move - update distance manager");
+//        chunkMapPlayerMoveUpdatePlayerMap = Timings.ofSafe("Chunk map player move - update player map");
+//        chunkMapUpdatePlayerMaps = Timings.ofSafe("Chunk map update player maps");
+        playerChunkLoaderUpdate = Timings.ofSafe("PlayerChunkLoader update");
+        playerChunkLoaderUpdateGetViewDistances = Timings.ofSafe("PlayerChunkLoader update - get view distances");
+        playerChunkLoaderUpdateDecideWhetherToRecalculate = Timings.ofSafe("PlayerChunkLoader update - decide whether to recalculate");
+//        chunkMapPlayerMoveUpdateChunkTrackingOrSeeing = Timings.ofSafe("Chunk map player move - update chunk tracking or seeing");
+//        chunkMapPlayerMoveSortChunksForTrackAndSee = Timings.ofSafe("Chunk map player move - sort chunks for track and see");
+        computeTrackViewDistance = Timings.ofSafe("Compute track view distance");
+        computeSeeViewDistance = Timings.ofSafe("Compute see view distance");
+        computeLoadViewDistance = Timings.ofSafe("Compute load view distance");
+        trackViewDistanceMayHaveChanged = Timings.ofSafe("Track view distance may have changed");
+        seeViewDistanceMayHaveChanged = Timings.ofSafe("See view distance may have changed");
+        loadViewDistanceMayHaveChanged = Timings.ofSafe("Load view distance may have changed");
+        processTrackViewDistanceChange = Timings.ofSafe("Process track view distance change");
+        processSeeViewDistanceChange = Timings.ofSafe("Process see view distance change");
+        // Suki end - per-player view distance
 
         miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
 
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 0d43afcdd5db346d0ddf82e06bad5b219721715c..831dd74063fc576b9475fde96da7da71181fbb46 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -24,6 +24,7 @@ import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.TreeSet;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -49,31 +50,33 @@ public final class PlayerChunkLoader {
         return data.getTargetTickViewDistance();
     }
 
-    public static int getLoadViewDistance(final Player player) {
-        return getLoadViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getLoadViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
-        }
-        return data.getLoadDistance();
-    }
-
-    public static int getSendViewDistance(final Player player) {
-        return getSendViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getSendViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
-    }
+    // Suki start - per-player view distance
+//    public static int getLoadViewDistance(final Player player) {
+//        return getLoadViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getLoadViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
+//        }
+//        return data.getLoadDistance();
+//    }
+
+//    public static int getSendViewDistance(final Player player) {
+//        return getSendViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getSendViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+//    }
+    // Suki end - per-player view distance
 
     protected final ChunkMap chunkMap;
     protected final Reference2ObjectLinkedOpenHashMap<ServerPlayer, PlayerLoaderData> playerMap = new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f);
@@ -135,7 +138,15 @@ public final class PlayerChunkLoader {
     /**
      * The chunks to be sent to players, provided they're send-ready. Send-ready means the chunk and its 1 radius neighbours are loaded.
      */
-    public final PlayerAreaMap broadcastMap;
+    // Suki start - per-player track and see view distance
+    public final PlayerAreaMap broadcastMapForTracking;
+    public final PlayerAreaMap broadcastMapForSeeing;
+
+    public PlayerAreaMap getBroadcastMap(final boolean concernsTracking) {
+        return concernsTracking ? this.broadcastMapForTracking : this.broadcastMapForSeeing;
+    }
+
+    // Suki end - per-player track and see view distance
 
     /**
      * The chunks to be brought up to send-ready status. Send-ready means the chunk and its 1 radius neighbours are loaded.
@@ -153,15 +164,17 @@ public final class PlayerChunkLoader {
      */
     public final PlayerAreaMap tickMap;
 
-    /**
-     * -1 if defaulting to [load distance], else always in [2, load distance]
-     */
-    protected int rawSendDistance = -1;
-
-    /**
-     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
-     */
-    protected int rawLoadDistance = -1;
+    // Suki start - per-player view distance
+//    /**
+//     * -1 if defaulting to [load distance], else always in [2, load distance]
+//     */
+//    protected int rawSendDistance = -1;
+//
+//    /**
+//     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
+//     */
+//    protected int rawLoadDistance = -1;
+    // Suki end - per-player view distance
 
     /**
      * Never -1, always in [2, 32]
@@ -178,47 +191,49 @@ public final class PlayerChunkLoader {
         this.setTickDistance(distance);
     }
 
-    public int getTargetNoTickViewDistance() {
-        return this.getLoadDistance() - 1;
-    }
-
-    public void setTargetNoTickViewDistance(final int distance) {
-        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
-    }
-
-    public int getTargetSendDistance() {
-        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
-    }
-
-    public void setTargetSendDistance(final int distance) {
-        this.setSendDistance(distance);
-    }
-
-    // internal methods
-
-    public int getSendDistance() {
-        final int loadDistance = this.getLoadDistance();
-        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
-    }
-
-    public void setSendDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Send distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawSendDistance = distance;
-    }
-
-    public int getLoadDistance() {
-        final int tickDistance = this.getTickDistance();
-        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
-    }
-
-    public void setLoadDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Load distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawLoadDistance = distance;
-    }
+    // Suki start - per-player view distance
+//    public int getTargetNoTickViewDistance() {
+//        return this.getLoadDistance() - 1;
+//    }
+//
+//    public void setTargetNoTickViewDistance(final int distance) {
+//        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
+//    }
+//
+//    public int getTargetSendDistance() {
+//        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
+//    }
+//
+//    public void setTargetSendDistance(final int distance) {
+//        this.setSendDistance(distance);
+//    }
+//
+//    // internal methods
+//
+//    public int getSendDistance() {
+//        final int loadDistance = this.getLoadDistance();
+//        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
+//    }
+//
+//    public void setSendDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException("Send distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
+//        }
+//        this.rawSendDistance = distance;
+//    }
+//
+//    public int getLoadDistance() {
+//        final int tickDistance = this.getTickDistance();
+//        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
+//    }
+//
+//    public void setLoadDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException("Load distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
+//        }
+//        this.rawLoadDistance = distance;
+//    }
+    // Suki end - per-player view distance
 
     public int getTickDistance() {
         return this.rawTickDistance;
@@ -256,12 +271,20 @@ public final class PlayerChunkLoader {
 
     public PlayerChunkLoader(final ChunkMap chunkMap, final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
         this.chunkMap = chunkMap;
-        this.broadcastMap = new PlayerAreaMap(pooledHashSets,
+        // Suki start - player track and see view distance
+        this.broadcastMapForTracking = new PlayerAreaMap(pooledHashSets,
+                null,
+                (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, true);
+                });
+        this.broadcastMapForSeeing = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
                  com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
-                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ);
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, false);
                 });
+        // Suki end - player track and see view distance
         this.loadMap = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
@@ -311,12 +334,16 @@ public final class PlayerChunkLoader {
     protected final LongOpenHashSet isTargetedForPlayerLoad = new LongOpenHashSet();
     protected final LongOpenHashSet chunkTicketTracker = new LongOpenHashSet();
 
-    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
+    // Suki start - per-player track and see view distance
+
+    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ, boolean concernsTracking) {
+        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
         return playersInSendRange != null;
     }
 
+    // Suki end - per-player track and see view distance
+
     public void onChunkPostProcessing(final int chunkX, final int chunkZ) {
         this.onChunkSendReady(chunkX, chunkZ);
     }
@@ -348,34 +375,38 @@ public final class PlayerChunkLoader {
         return levelChunk != null && levelChunk.isPostProcessingDone && this.isTargetedForPlayerLoad.contains(key);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly) {
-        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ) : this.isChunkSent(player, chunkX, chunkZ);
+    // Suki start - per-player track and see view distance
+
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly, final boolean concernsTracking) {
+        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ, concernsTracking) : this.isChunkSent(player, chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        return data.hasSentChunk(chunkX, chunkZ);
+        return data.hasSentChunk(chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        final boolean center = data.hasSentChunk(chunkX, chunkZ);
+        final boolean center = data.hasSentChunk(chunkX, chunkZ, concernsTracking);
         if (!center) {
             return false;
         }
 
-        return !(data.hasSentChunk(chunkX - 1, chunkZ) && data.hasSentChunk(chunkX + 1, chunkZ) &&
-            data.hasSentChunk(chunkX, chunkZ - 1) && data.hasSentChunk(chunkX, chunkZ + 1));
+        return !(data.hasSentChunk(chunkX - 1, chunkZ, concernsTracking) && data.hasSentChunk(chunkX + 1, chunkZ, concernsTracking) &&
+            data.hasSentChunk(chunkX, chunkZ - 1, concernsTracking) && data.hasSentChunk(chunkX, chunkZ + 1, concernsTracking));
     }
 
+    // Suki end - per-player track and see view distance
+
     protected int getMaxConcurrentChunkSends() {
         return GlobalConfiguration.get().chunkLoading.maxConcurrentSends;
     }
@@ -400,47 +431,55 @@ public final class PlayerChunkLoader {
     }
 
     public void onChunkSendReady(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
 
-        if (playersInSendRange == null) {
-            return;
-        }
+        // Suki start - per-player track and see view distance
 
-        final Object[] rawData = playersInSendRange.getBackingSet();
-        for (int i = 0, len = rawData.length; i < len; ++i) {
-            final Object raw = rawData[i];
+        for (boolean concernsTracking : new boolean[] {false, true}) {
+            final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
-            if (!(raw instanceof ServerPlayer)) {
-                continue;
+            if (playersInSendRange == null) {
+                return;
+            }
+
+            final Object[] rawData = playersInSendRange.getBackingSet();
+            for (int i = 0, len = rawData.length; i < len; ++i) {
+                final Object raw = rawData[i];
+
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                this.onChunkSendReady((ServerPlayer) raw, chunkX, chunkZ, concernsTracking);
             }
-            this.onChunkSendReady((ServerPlayer)raw, chunkX, chunkZ);
         }
+
+        // Suki end - per-player track and see view distance
+
     }
 
-    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Suki - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        if (data.hasSentChunk(chunkX, chunkZ) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) {
+        if (data.hasSentChunk(chunkX, chunkZ, concernsTracking) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) { // Suki - per-player track and see view distance
             // if we don't have player tickets, then the load logic will pick this up and queue to send
             return;
         }
 
-        if (!data.chunksToBeSent.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        if (!data.getChunksToBeSent(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) { // Suki - per-player track and see view distance
             // don't queue to send, we don't want the chunk
             return;
         }
 
-        final long playerPos = this.broadcastMap.getLastCoordinate(player);
+        final long playerPos = this.broadcastMapForSeeing.getLastCoordinate(player); // Suki - per-player track and see view distance
         final int playerChunkX = CoordinateUtils.getChunkX(playerPos);
         final int playerChunkZ = CoordinateUtils.getChunkZ(playerPos);
         final int manhattanDistance = Math.abs(playerChunkX - chunkX) + Math.abs(playerChunkZ - chunkZ);
 
         final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, 0.0);
-        data.sendQueue.add(holder);
+        data.getSendQueue(concernsTracking).add(holder); // Suki - per-player track and see view distance
     }
 
     public void onChunkLoad(final int chunkX, final int chunkZ) {
@@ -449,14 +488,14 @@ public final class PlayerChunkLoader {
         }
     }
 
-    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Suki - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        data.unloadChunk(chunkX, chunkZ);
+        data.unloadChunk(chunkX, chunkZ, concernsTracking); // Suki - per-player track and see view distance
     }
 
     public void addPlayer(final ServerPlayer player) {
@@ -466,7 +505,7 @@ public final class PlayerChunkLoader {
         }
         final PlayerLoaderData data = new PlayerLoaderData(player, this);
         if (this.playerMap.putIfAbsent(player, data) == null) {
-            data.update();
+            data.update(true); // Suki - per-player view distance
         }
     }
 
@@ -492,14 +531,14 @@ public final class PlayerChunkLoader {
         }
     }
 
-    public void updatePlayer(final ServerPlayer player) {
+    public void updatePlayer(final ServerPlayer player, boolean recalculateMapsIfOnlyViewDistanceChanged) { // Suki - per-player view distance
         TickThread.ensureTickThread("Cannot update player async");
         if (!player.isRealPlayer) {
             return;
         }
         final PlayerLoaderData loaderData = this.playerMap.get(player);
         if (loaderData != null) {
-            loaderData.update();
+            loaderData.update(recalculateMapsIfOnlyViewDistanceChanged); // Suki - per-player view distance
         }
     }
 
@@ -510,7 +549,7 @@ public final class PlayerChunkLoader {
     public void tick() {
         TickThread.ensureTickThread("Cannot tick async");
         for (final PlayerLoaderData data : this.playerMap.values()) {
-            data.update();
+            data.update(true); // Suki - per-player view distance
         }
         this.tickMidTick();
     }
@@ -559,7 +598,14 @@ public final class PlayerChunkLoader {
 
             final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
 
-            final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
+            // Suki start - per-player track and see view distance
+            ChunkPriorityHolder queuedSend = data.getSendQueue(true).pollFirst();
+            boolean concernsTracking = true;
+            if (queuedSend == null) {
+                queuedSend = data.getSendQueue(false).pollFirst();
+                concernsTracking = false;
+            }
+            // Suki end - per-player track and see view distance
             if (queuedSend == null) {
                 concurrentChunkSends.getAndDecrement(); // we never sent, so decrease
                 // stop iterating over players who have nothing to send
@@ -596,7 +642,7 @@ public final class PlayerChunkLoader {
                 }
 
                 concurrentChunkSends.getAndDecrement();
-            });
+            }, concernsTracking);
 
             nextChunkSend = this.getMaxSendAddend() + time;
             if (time < nextChunkSend) {
@@ -776,7 +822,10 @@ public final class PlayerChunkLoader {
         // this is corrected so that 0 is along the positive x-axis
         protected float lastYaw = Float.NEGATIVE_INFINITY;
 
-        protected int lastSendDistance = Integer.MIN_VALUE;
+        // Suki start - per-player track and see view distance
+        protected int lastTrackDistance = Integer.MIN_VALUE;
+        protected int lastSeeDistance = Integer.MIN_VALUE;
+        // Suki end - per-player track and see view distance
         protected int lastLoadDistance = Integer.MIN_VALUE;
         protected int lastTickDistance = Integer.MIN_VALUE;
         protected boolean usingLookingPriority;
@@ -787,28 +836,29 @@ public final class PlayerChunkLoader {
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
         protected final ArrayDeque<ChunkPriorityHolder> loadQueue = new ArrayDeque<>();
-        protected final LongOpenHashSet sentChunks = new LongOpenHashSet();
-        protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
-            final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
-            if (distanceCompare != 0) {
-                return distanceCompare;
-            }
+        // Suki start - per-player view distance
 
-            final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
-            if (coordinateXCompare != 0) {
-                return coordinateXCompare;
-            }
+        protected final LongOpenHashSet sentChunksForTracking = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForTracking = new LongOpenHashSet();
 
-            return Integer.compare(p1.chunkZ, p2.chunkZ);
-        });
+        protected final LongOpenHashSet sentChunksForSeeing = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForSeeing = new LongOpenHashSet();
 
-        protected int sendViewDistance = -1;
-        protected int loadViewDistance = -1;
-        protected int tickViewDistance = -1;
+        private TreeSet<ChunkPriorityHolder> createSendQueue() {
+            return new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
+                final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
+                if (distanceCompare != 0) {
+                    return distanceCompare;
+                }
 
-        protected long nextChunkSendTarget;
+                final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
+                if (coordinateXCompare != 0) {
+                    return coordinateXCompare;
+                }
+                return Integer.compare(p1.chunkZ, p2.chunkZ);
+            });
+        }
 
         // this interval prevents bursting a lot of chunk loads
         protected final IntervalledCounter ticketAdditionCounterShort = new IntervalledCounter((long)(1.0e6 * 50.0)); // 50ms
@@ -822,35 +872,59 @@ public final class PlayerChunkLoader {
             this.loader = loader;
         }
 
-        // these view distance methods are for api
-        public int getTargetSendViewDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-            final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
-            return sendViewDistance;
-        }
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForTracking = createSendQueue();
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForSeeing = createSendQueue();
 
-        public void setTargetSendViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
-            }
-            this.sendViewDistance = distance;
+        protected LongOpenHashSet getSentChunks(final boolean concernsTracking) {
+            return concernsTracking ? this.sentChunksForTracking : this.sentChunksForSeeing;
         }
-
-        public int getTargetNoTickViewDistance() {
-            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+        protected LongOpenHashSet getChunksToBeSent(final boolean concernsTracking) {
+            return concernsTracking ? this.chunksToBeSentForTracking : this.chunksToBeSentForSeeing;
         }
 
-        public void setTargetNoTickViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
-                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
-            }
-            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+        protected TreeSet<ChunkPriorityHolder> getSendQueue(final boolean concernsTracking) {
+            return concernsTracking ? this.sendQueueForTracking : this.sendQueueForSeeing;
         }
 
+//        protected int sendViewDistance = -1;
+//        protected int loadViewDistance = -1;
+        public int tickViewDistance = -1;
+
+        protected long nextChunkSendTarget;
+
+//        // these view distance methods are for api
+//        public int getTargetSendViewDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//            final int clientViewDistance = this.getClientViewDistance();
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            return sendViewDistance;
+//        }
+//
+//        public void setTargetSendViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
+//            }
+//            this.sendViewDistance = distance;
+//        }
+//
+//        public int getTargetNoTickViewDistance() {
+//            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+//        }
+//
+//        public void setTargetNoTickViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
+//                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
+//            }
+//            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+//        }
+
+        // Suki end - per-player view distance
+
         public int getTargetTickViewDistance() {
-            return this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+            // Suki start - per-player load distance
+            return player.getTickingViewDistance();
+            // Suki end - per-player load distance
         }
 
         public void setTargetTickViewDistance(final int distance) {
@@ -860,33 +934,37 @@ public final class PlayerChunkLoader {
             this.tickViewDistance = distance;
         }
 
-        protected int getLoadDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//        protected int getLoadDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//
+//            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//        }
 
-            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-        }
+        // Suki start - per-player view distance
 
-        public boolean hasSentChunk(final int chunkX, final int chunkZ) {
-            return this.sentChunks.contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        public boolean hasSentChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            return this.getSentChunks(concernsTracking).contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
         }
 
-        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend) {
-            if (this.sentChunks.add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true, concernsTracking); // unloaded, loaded
                 this.player.connection.connection.execute(onChunkSend);
             } else {
                 throw new IllegalStateException();
             }
         }
 
-        public void unloadChunk(final int chunkX, final int chunkZ) {
-            if (this.sentChunks.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void unloadChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), null, true, false); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), null, true, false, concernsTracking); // unloaded, loaded
             }
         }
 
+        // Suki end - per-player view distance
+
         protected static boolean wantChunkLoaded(final int centerX, final int centerZ, final int chunkX, final int chunkZ,
                                                  final int sendRadius) {
             // expect sendRadius to be = 1 + target viewable radius
@@ -928,7 +1006,10 @@ public final class PlayerChunkLoader {
         }
 
         public void remove() {
-            this.loader.broadcastMap.remove(this.player);
+            // Suki start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).remove(this.player);
+            this.loader.getBroadcastMap(true).remove(this.player);
+            // Suki end - per-player track and see view distance
             this.loader.loadMap.remove(this.player);
             this.loader.loadTicketCleanup.remove(this.player);
             this.loader.tickMap.remove(this.player);
@@ -938,13 +1019,20 @@ public final class PlayerChunkLoader {
             return this.player.clientViewDistance == null ? -1 : Math.max(0, this.player.clientViewDistance.intValue());
         }
 
-        public void update() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+        // Suki start - per-player view distance
+        public void update(boolean recalculateMapsIfOnlyViewDistanceChanged) { // Only recalculate the chunk loading maps if only the view distance changed in specific scenarios (world change, tick) and not every time the player moves (in which case we will still update the chunk loading maps if the player moved to a different chunk, of course)
+            this.player.level.timings.playerChunkLoaderUpdate.startTiming(); try {
+            this.player.level.timings.playerChunkLoaderUpdateGetViewDistances.startTiming();
+            final int loadViewDistance = this.player.getLoadViewDistance();
             // load view cannot be less-than tick view + 1
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+            final int tickViewDistance = this.player.getTickingViewDistance();
             // send view cannot be greater-than load view
             final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+            final int trackViewDistance = this.player.getTrackViewDistance();
+            final int seeViewDistance = this.player.getSeeViewDistance();
+            this.player.level.timings.playerChunkLoaderUpdateGetViewDistances.stopTiming();
+            // Suki end - per-player view distance
 
             final double posX = this.player.getX();
             final double posZ = this.player.getZ();
@@ -957,11 +1045,14 @@ public final class PlayerChunkLoader {
             // make sure we're in the send queue
             this.loader.chunkSendWaitQueue.add(this);
 
+            this.player.level.timings.playerChunkLoaderUpdateDecideWhetherToRecalculate.startTiming(); try { // Suki - per-player view distance
             if (
                 // has view distance stayed the same?
-                    sendViewDistance == this.lastSendDistance
+                // Suki start - per-player view distance
+                (!recalculateMapsIfOnlyViewDistanceChanged || (trackViewDistance == this.lastTrackDistance && seeViewDistance == this.lastSeeDistance // Suki - per-player track and see view distance
                             && loadViewDistance == this.lastLoadDistance
-                            && tickViewDistance == this.lastTickDistance
+                            && tickViewDistance == this.lastTickDistance))
+                        // Suki end - per-player view distance
 
                             && (this.usingLookingPriority ? (
                                     // has our block stayed the same (this also accounts for chunk change)?
@@ -982,21 +1073,26 @@ public final class PlayerChunkLoader {
                 // nothing we care about changed, so we're not re-calculating
                 return;
             }
+            } finally { this.player.level.timings.playerChunkLoaderUpdateDecideWhetherToRecalculate.stopTiming(); }  // Suki - per-player view distance
 
             final int centerChunkX = Mth.floor(posX) >> 4;
             final int centerChunkZ = Mth.floor(posZ) >> 4;
 
             final boolean needsChunkCenterUpdate = (centerChunkX != this.lastChunkX) || (centerChunkZ != this.lastChunkZ);
-            this.loader.broadcastMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, sendViewDistance);
+
+            // Suki start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).addOrUpdate(this.player, centerChunkX, centerChunkZ, seeViewDistance);
+            this.loader.getBroadcastMap(true).addOrUpdate(this.player, centerChunkX, centerChunkZ, trackViewDistance);
+            // Suki end - per-player track and see view distance
             this.loader.loadMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance);
             this.loader.loadTicketCleanup.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance + 1);
             this.loader.tickMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, tickViewDistance);
 
-            if (sendViewDistance != this.lastSendDistance) {
+            if (seeViewDistance != this.lastSeeDistance) { // Suki - per-player track and see view distance
                 // update the view radius for client
                 // note that this should be after the map calls because the client wont expect unload calls not in its VD
                 // and it's possible we decreased VD here
-                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(sendViewDistance));
+                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(seeViewDistance)); // Suki - per-player track and see view distance
             }
             if (tickViewDistance != this.lastTickDistance) {
                 this.player.connection.send(new ClientboundSetSimulationDistancePacket(tickViewDistance));
@@ -1005,7 +1101,10 @@ public final class PlayerChunkLoader {
             this.lastLocX = posX;
             this.lastLocZ = posZ;
             this.lastYaw = yaw;
-            this.lastSendDistance = sendViewDistance;
+            // Suki start - per-player track and see view distance
+            this.lastTrackDistance = trackViewDistance;
+            this.lastSeeDistance = seeViewDistance;
+            // Suki start - per-player track and see view distance
             this.lastLoadDistance = loadViewDistance;
             this.lastTickDistance = tickViewDistance;
             this.usingLookingPriority = useLookPriority;
@@ -1035,76 +1134,87 @@ public final class PlayerChunkLoader {
 
             final List<ChunkPriorityHolder> loadQueue = new ArrayList<>();
 
+            // Suki start - per-player track and see view distance
+
             // clear send queue, we are re-sorting
-            this.sendQueue.clear();
+            this.getSendQueue(false).clear();
+            this.getSendQueue(true).clear();
             // clear chunk want set, vd/position might have changed
-            this.chunksToBeSent.clear();
-
-            final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
-
-            for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
-                for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
-                    final int chunkX = dx + centerChunkX;
-                    final int chunkZ = dz + centerChunkZ;
-                    final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
-                    final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
-
-                    if (this.hasSentChunk(chunkX, chunkZ)) {
-                        // already sent (which means it is also loaded)
-                        if (!sendChunk) {
-                            // have sent the chunk, but don't want it anymore
-                            // unload it now
-                            this.unloadChunk(chunkX, chunkZ);
+            this.getChunksToBeSent(false).clear();
+            this.getChunksToBeSent(true).clear();
+
+            for (boolean concernsTracking : new boolean[] {false, true}) {
+
+                final int sendViewDistance = concernsTracking ? trackViewDistance : seeViewDistance;
+
+                final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
+
+                for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
+                    for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
+                        final int chunkX = dx + centerChunkX;
+                        final int chunkZ = dz + centerChunkZ;
+                        final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
+                        final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
+
+                        if (this.hasSentChunk(chunkX, chunkZ, concernsTracking)) {
+                            // already sent (which means it is also loaded)
+                            if (!sendChunk) {
+                                // have sent the chunk, but don't want it anymore
+                                // unload it now
+                                this.unloadChunk(chunkX, chunkZ, concernsTracking);
+                            }
+                            continue;
                         }
-                        continue;
-                    }
 
-                    final boolean loadChunk = squareDistance <= loadViewDistance;
+                        final boolean loadChunk = squareDistance <= loadViewDistance;
 
-                    final boolean prioritised = useLookPriority && triangleIntersects(
+                        final boolean prioritised = useLookPriority && triangleIntersects(
                             // prioritisation triangle
                             p1x, p1z, p2x, p2z, p3x, p3z,
 
                             // center of chunk
-                            (double)((chunkX << 4) | 8), (double)((chunkZ << 4) | 8)
-                    );
+                            (double) ((chunkX << 4) | 8), (double) ((chunkZ << 4) | 8)
+                        );
 
-                    final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
+                        final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
 
-                    final double priority;
+                        final double priority;
 
-                    if (squareDistance <= GlobalConfiguration.get().chunkLoading.minLoadRadius) {
-                        // priority should be negative, and we also want to order it from center outwards
-                        // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
-                        priority = -((2 * GlobalConfiguration.get().chunkLoading.minLoadRadius + 1) - manhattanDistance);
-                    } else {
-                        if (prioritised) {
-                            // we don't prioritise these chunks above others because we also want to make sure some chunks
-                            // will be loaded if the player changes direction
-                            priority = (double)manhattanDistance / 6.0;
+                        if (squareDistance <= GlobalConfiguration.get().chunkLoading.minLoadRadius) {
+                            // priority should be negative, and we also want to order it from center outwards
+                            // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
+                            priority = -((2 * GlobalConfiguration.get().chunkLoading.minLoadRadius + 1) - manhattanDistance);
                         } else {
-                            priority = (double)manhattanDistance;
+                            if (prioritised) {
+                                // we don't prioritise these chunks above others because we also want to make sure some chunks
+                                // will be loaded if the player changes direction
+                                priority = (double) manhattanDistance / 6.0;
+                            } else {
+                                priority = (double) manhattanDistance;
+                            }
                         }
-                    }
 
-                    final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
+                        final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
 
-                    if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
-                        if (loadChunk) {
-                            loadQueue.add(holder);
+                        if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
+                            if (loadChunk) {
+                                loadQueue.add(holder);
+                                if (sendChunk) {
+                                    this.getChunksToBeSent(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                }
+                            }
+                        } else {
+                            // loaded but not sent: so queue it!
                             if (sendChunk) {
-                                this.chunksToBeSent.add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                this.getSendQueue(concernsTracking).add(holder);
                             }
                         }
-                    } else {
-                        // loaded but not sent: so queue it!
-                        if (sendChunk) {
-                            this.sendQueue.add(holder);
-                        }
                     }
                 }
             }
 
+            // Suki end - per-player track and see view distance
+
             loadQueue.sort((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
                 return Double.compare(p1.priority, p2.priority);
             });
@@ -1123,6 +1233,9 @@ public final class PlayerChunkLoader {
             if (needsChunkCenterUpdate) {
                 this.player.connection.send(new ClientboundSetChunkCacheCenterPacket(centerChunkX, centerChunkZ));
             }
+
+            } finally { this.player.level.timings.playerChunkLoaderUpdate.stopTiming(); }  // Suki - per-player view distance]
+
         }
     }
 }
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index efd5beaeddbd4337dd0cc8362b68cf630e1d97ff..0130e2c3c047055fbea9c3d893a9b4593fa10ed2 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -8,7 +8,6 @@ import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.format.NamedTextColor;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ServerboundPlaceRecipePacket;
-import net.minecraft.server.level.ServerPlayer;
 import org.bukkit.Bukkit; // Pufferfish
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.spongepowered.configurate.objectmapping.ConfigSerializable;
diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index 199631c34436f168138633e8405f2ab9004b69be..37a6894fba46eb8b091d88e9ab73b801d6ba6213 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -24,6 +24,7 @@ import net.minecraft.Util;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MobCategory;
@@ -33,7 +34,6 @@ import net.minecraft.world.item.Item;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.NaturalSpawner;
 import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
-import org.bukkit.entity.Wither;
 import org.slf4j.Logger;
 import org.spigotmc.SpigotWorldConfig;
 import org.spongepowered.configurate.objectmapping.ConfigSerializable;
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index cae99d217f40f6bc8337619b6e26153ccf261fc2..139b4b49f635c5ec123b0562194377ae12250446 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -663,7 +663,12 @@ public final class MCUtil {
             });
 
             worldData.addProperty("name", world.getWorld().getName());
-            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()); // Paper - replace chunk loader system
+            // Suki start - per-player view distance
+            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.getVanillaWorldViewDistance()); // Paper - replace chunk loader system
+            worldData.addProperty("max-track-view-distance", world.sukiConfig().viewDistance.track.getMax());
+            worldData.addProperty("max-see-view-distance", world.sukiConfig().viewDistance.see.getMax());
+            worldData.addProperty("max-load-view-distance", world.sukiConfig().viewDistance.load.getMax());
+            // Suki end - per-player view distance
             worldData.addProperty("tick-view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig().spawn.keepSpawnLoadedRange * 16);
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index a041161dee9a857d43c83fb677dba7e90a6a5d24..15e22def419e314b1433b9043d02a0625bc7e967 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -414,7 +414,7 @@ public class ChunkHolder {
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
-        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMap; // Paper - replace old player chunk manager
+        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMapForTracking; // Paper - replace old player chunk manager // Suki - per-player track and see view distance
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = viewDistanceMap.getObjectsInRange(this.pos);
         if (players == null) {
             return;
@@ -427,7 +427,7 @@ public class ChunkHolder {
                 continue;
             }
             ServerPlayer player = (ServerPlayer)temp;
-            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge)) {
+            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge, true)) { // Suki - per-player track and see view distance
                 continue;
             }
             player.connection.send(packet);
@@ -856,7 +856,8 @@ public class ChunkHolder {
 
     public interface PlayerProvider {
 
-        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge);
+        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking); // Suki - per-player track and see view distance
+
     }
 
     private static final class ChunkSaveDebug {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 877afa898a35f1ef12543394f052bb18cdad4257..926db8e5541eef4907e2641956a7148185817bc0 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -170,7 +170,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
-    int viewDistance;
+    // Martijn start- per-player view distance
+    // This value is the intended world send view distance + 1
+    private int vanillaWorldViewDistancePlusOne;
+    // Suki end - per-player view distance
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
     public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
 
@@ -255,7 +258,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player))); // Paper - per player view distances
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Paper - per player view distances // Suki - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         // Note: players need to be explicitly added to distance maps before they can be updated
@@ -288,7 +291,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.playerChunkManager.removePlayer(player); // Paper - replace chunk loader
     }
 
-    void updateMaps(ServerPlayer player) {
+    void updateMaps(ServerPlayer player, boolean recalculateChunkLoadingMapsIfOnlyViewDistanceChanged) { // Suki - per-player view distance
         int chunkX = MCUtil.getChunkCoordinate(player.getX());
         int chunkZ = MCUtil.getChunkCoordinate(player.getZ());
         // Note: players need to be explicitly added to distance maps before they can be updated
@@ -297,7 +300,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player))); // Paper - per player view distances
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Paper - per player view distances // Suki - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE); // Paper - optimise ChunkMap#anyPlayerCloseEnoughForSpawning
@@ -307,7 +310,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             this.playerMobDistanceMap.update(player, chunkX, chunkZ, this.distanceManager.getSimulationDistance());
         }
         // Paper end - per player mob spawning
-        this.playerChunkManager.updatePlayer(player); // Paper - replace chunk loader
+        this.playerChunkManager.updatePlayer(player, recalculateChunkLoadingMapsIfOnlyViewDistanceChanged); // Paper - replace chunk loader // Suki - per-player view distance
     }
     // Paper end
     // Paper start
@@ -474,7 +477,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Suki end - sort chunks by distance
 
     boolean unloadingPlayerChunk = false; // Paper - do not allow ticket level changes while unloading chunks
-    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
+    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int vanillaWorldViewDistance, boolean dsync) { // Suki - per-player view distance
         super(session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - don't copy
         this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
@@ -532,7 +535,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(path.resolve("poi"), dataFixer, dsync, world.registryAccess(), world);
-        this.setViewDistance(viewDistance);
+        this.setVanillaWorldViewDistance(vanillaWorldViewDistance); // Suki - per-player view distance
         // Paper start
         this.dataRegionManager = new io.papermc.paper.chunk.SingleThreadChunkRegionManager(this.level, 2, (1.0 / 3.0), 1, 6, "Data", DataRegionData::new, DataRegionSectionData::new);
         this.regionManagers.add(this.dataRegionManager);
@@ -779,13 +782,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
+    // Suki start - per-player view distance
     // Paper start
-    public final int getEffectiveViewDistance() {
+    public final int getVanillaWorldViewDistance() {
         // TODO this needs to be checked on update
         // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
-        return this.viewDistance - 1;
+        return this.vanillaWorldViewDistancePlusOne - 1;
     }
     // Paper end
+    // Suki end - per-player view distance
 
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
         List<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> list = new ArrayList();
@@ -1679,17 +1684,20 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
-    public void setViewDistance(int watchDistance) {
-        int j = Mth.clamp(watchDistance + 1, (int) 3, (int) 33);
+    // Suki start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        int newVanillaWorldViewDistancePlusOne = Mth.clamp(vanillaWorldViewDistance + 1, (int) 3, (int) 33);
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
+        if (newVanillaWorldViewDistancePlusOne != this.vanillaWorldViewDistancePlusOne) {
+            int k = this.vanillaWorldViewDistancePlusOne;
 
-            this.viewDistance = j;
-            this.playerChunkManager.setLoadDistance(this.viewDistance); // Paper - replace player loader system
+            this.vanillaWorldViewDistancePlusOne = newVanillaWorldViewDistancePlusOne;
+            // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//            this.playerChunkManager.setLoadDistance(Mth.clamp(this.vanillaWorldViewDistancePlusOne, 2, 32)); // Paper - replace player loader system
         }
 
     }
+    // Suki end - per-player view distance
 
     // Paper start - replace player loader system
     public void setTickViewDistance(int distance) {
@@ -1697,7 +1705,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end - replace player loader system
 
-    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance) { // Paper - Anti-Xray - Bypass // Paper - public
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Suki - per-player track and see view distance
         if (player.level == this.level) {
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
@@ -1706,7 +1714,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     LevelChunk chunk = playerchunk.getSendingChunk(); // Paper - replace chunk loader system
 
                     if (chunk != null) {
-                        this.playerLoadedChunk(player, packet, chunk);
+                        this.playerLoadedChunk(player, packet, chunk, concernsTracking); // Suki - per-player track and see view distance
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -1714,7 +1722,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (!newWithinViewDistance && oldWithinViewDistance) {
-                player.untrackChunk(pos);
+                player.untrackChunk(pos, concernsTracking); // Suki - per-player track and see view distance
             }
 
         }
@@ -1999,6 +2007,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public void move(ServerPlayer player) {
         // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
+        this.level.timings.chunkMapPlayerMove.startTiming(); // Suki - per-player view distance
+
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
@@ -2039,19 +2049,23 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         // Paper - replaced by PlayerChunkLoader
 
-        this.updateMaps(player); // Paper - distance maps
-        this.playerChunkManager.updatePlayer(player); // Paper - respond to movement immediately
+        // Suki start - per-player view distance
+        this.updateMaps(player, false); // Paper - distance maps
+        this.playerChunkManager.updatePlayer(player, false); // Paper - respond to movement immediately
+        // Suki end - per-player view distance
+
+        this.level.timings.chunkMapPlayerMove.stopTiming(); // Suki - per-player view distance
 
     }
 
     @Override
-    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
+    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking) { // Suki - per-player track and see view distance
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
         List<ServerPlayer> ret = new java.util.ArrayList<>(4);
 
-        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.broadcastMap.getObjectsInRange(chunkPos);
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.getBroadcastMap(concernsTracking).getObjectsInRange(chunkPos); // Suki - per-player track and see view distance
         if (players == null) {
             return ret;
         }
@@ -2196,6 +2210,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimised tracker
 
     protected void tick() {
+
+        // Suki start - temporary debug message containing the number of loaded chunks
+        if (this.level.sukiConfig().viewDistance.load.printLoadedChunksInterval > 0 && Math.random() < 1.0 / this.level.sukiConfig().viewDistance.load.printLoadedChunksInterval) {
+            org.bukkit.Bukkit.getLogger().info("Number of loaded chunks in " + this.level.getWorld().getName() + ": " + this.level.getWorld().getLoadedChunks().length);
+        }
+        // Suki end - temporary debug message containing the number of loaded chunks
+
         // Paper start - optimized tracker
         if (true) {
             this.processTrackQueue();
@@ -2304,7 +2325,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - Fix MC-162253
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk) {
+    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Suki - per-player track and see view distance
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
@@ -2312,7 +2333,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
         player.trackChunk(chunk.getPos(), (Packet) cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
             // Paper start - Fix MC-162253
-            final int viewDistance = getEffectiveViewDistance();
+            final int viewDistance = getVanillaWorldViewDistance(); // Suki - per-player view distance
             final int playerChunkX = player.getBlockX() >> 4;
             final int playerChunkZ = player.getBlockZ() >> 4;
 
@@ -2351,58 +2372,67 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             // Paper end - Fix MC-162253
             return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
-        }));
+        }), concernsTracking);
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
-        List<Entity> list = Lists.newArrayList();
-        List<Entity> list1 = Lists.newArrayList();
-        // Paper start - optimise entity tracker
-        // use the chunk entity list, not the whole trackedEntities map...
-        Entity[] entities = chunk.entities.getRawData();
-        for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
-            Entity entity = entities[i];
-            if (entity == player) {
-                continue;
-            }
-            ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
-            if (tracker != null) { // dumb plugins... move on...
-                tracker.updatePlayer(player);
-            }
 
-            // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
-            // (and god knows what the leash thing is)
+        // Suki start - per-player track and see view distance
 
-            if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
-                list.add(entity);
-            }
+        if (concernsTracking) {
+
+            List<Entity> list = Lists.newArrayList();
+            List<Entity> list1 = Lists.newArrayList();
+            // Paper start - optimise entity tracker
+            // use the chunk entity list, not the whole trackedEntities map...
+            Entity[] entities = chunk.entities.getRawData();
+            for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
+                Entity entity = entities[i];
+                if (entity == player) {
+                    continue;
+                }
+                ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
+                if (tracker != null) { // dumb plugins... move on...
+                    tracker.updatePlayer(player);
+                }
 
-            if (!entity.getPassengers().isEmpty()) {
-                list1.add(entity);
+                // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+                // (and god knows what the leash thing is)
+
+                if (entity instanceof Mob && ((Mob) entity).getLeashHolder() != null) {
+                    list.add(entity);
+                }
+
+                if (!entity.getPassengers().isEmpty()) {
+                    list1.add(entity);
+                }
             }
-        }
-        // Paper end - optimise entity tracker
+            // Paper end - optimise entity tracker
 
-        Iterator iterator;
-        Entity entity1;
+            Iterator iterator;
+            Entity entity1;
 
-        if (!list.isEmpty()) {
-            iterator = list.iterator();
+            if (!list.isEmpty()) {
+                iterator = list.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+                }
             }
-        }
 
-        if (!list1.isEmpty()) {
-            iterator = list1.iterator();
+            if (!list1.isEmpty()) {
+                iterator = list1.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                player.connection.send(new ClientboundSetPassengersPacket(entity1));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    player.connection.send(new ClientboundSetPassengersPacket(entity1));
+                }
             }
+
         }
 
+        // Suki end - per-player track and see view distance
+
     }
 
     public PoiManager getPoiManager() {
@@ -2546,7 +2576,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 double vec3d_dx = player.getX() - this.entity.getX();
                 double vec3d_dz = player.getZ() - this.entity.getZ();
                 // Paper end - remove allocation of Vec3D here
-                double d0 = (double) Math.min(this.getEffectiveRange(), io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player) * 16); // Paper - per player view distance
+                double d0 = (double) Math.min(this.getEffectiveRange(), player.getTrackViewDistance() * 16); // Paper - per player view distance // Suki - per-player track view distance
                 double d1 = vec3d_dx * vec3d_dx + vec3d_dz * vec3d_dz; // Paper
                 double d2 = d0 * d0;
                 boolean flag = d1 <= d2 && this.entity.broadcastToPlayer(player);
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index d1b5c25b7455174e908cd6ed66789fa700190604..b8760409a1f88a74a8ea1787d6bf0a23b879bd5d 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -548,9 +548,12 @@ public abstract class DistanceManager {
         return arraysetsorted != null && !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).toString() : "no_ticket";
     }
 
-    protected void updatePlayerTickets(int viewDistance) {
-        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
-    }
+    // Suki start - per-player load view distance
+    // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//    protected void updatePlayerTickets(int viewDistance) {
+//        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
+//    }
+    // Suki end - per-player load view distance
 
     public void updateSimulationDistance(int simulationDistance) {
         this.chunkMap.playerChunkManager.setTargetTickViewDistance(simulationDistance); // Paper - route to player chunk manager
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 2bb545b505aa726b7ed7c757caed84bf0538782e..5f1f6e8bd7e7ec02803f14a0fc7f88d0c8d5fa9c 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -761,7 +761,7 @@ public class ServerChunkCache extends ChunkSource {
                     continue;
                 }
 
-                int viewDistance = this.chunkMap.getEffectiveViewDistance();
+                int viewDistance = this.chunkMap.getVanillaWorldViewDistance(); // Suki - per-player view distance
 
                 // copied and modified from isOutisdeRange
                 int chunkRange = level.spigotConfig.mobSpawnRange;
@@ -1034,9 +1034,11 @@ public class ServerChunkCache extends ChunkSource {
         this.chunkMap.broadcast(entity, packet);
     }
 
-    public void setViewDistance(int watchDistance) {
-        this.chunkMap.setViewDistance(watchDistance);
+    // Suki start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        this.chunkMap.setVanillaWorldViewDistance(vanillaWorldViewDistance);
     }
+    // Suki end - per-player view distance
 
     public void setSimulationDistance(int simulationDistance) {
         this.distanceManager.updateSimulationDistance(simulationDistance);
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 32be488845de5ceb10dca6fddad87a60b243f747..cc6d3cc740661b80322ed21f887aad0837fa7606 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1,6 +1,6 @@
 package net.minecraft.server.level;
 
-import com.destroystokyo.paper.PaperConfig;
+import co.aikar.timings.Timing;
 import com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
@@ -8,8 +8,6 @@ import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 
-import java.util.ArrayDeque;
-import java.util.BitSet;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -18,16 +16,12 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.UUID;
-import java.util.Random;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
+import io.papermc.paper.chunk.PlayerChunkLoader;
 import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.ints.IntIntPair;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
-import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -69,8 +63,6 @@ import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
 import net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket;
 import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundHorseScreenOpenPacket;
-import net.minecraft.network.protocol.game.ClientboundKeepAlivePacket;
-import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundMerchantOffersPacket;
 import net.minecraft.network.protocol.game.ClientboundOpenBookPacket;
@@ -87,14 +79,11 @@ import net.minecraft.network.protocol.game.ClientboundResourcePackPacket;
 import net.minecraft.network.protocol.game.ClientboundRespawnPacket;
 import net.minecraft.network.protocol.game.ClientboundServerDataPacket;
 import net.minecraft.network.protocol.game.ClientboundSetCameraPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetExperiencePacket;
 import net.minecraft.network.protocol.game.ClientboundSetHealthPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
 import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
-import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
 import net.minecraft.network.protocol.status.ServerStatus;
 import net.minecraft.resources.ResourceKey;
@@ -160,7 +149,6 @@ import net.minecraft.world.level.block.entity.CommandBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
-import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.portal.PortalInfo;
@@ -196,11 +184,293 @@ import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
 import org.sucraft.suki.configuration.SukiGlobalConfiguration;
+import org.jetbrains.annotations.NotNull;
 // CraftBukkit end
 
 public class ServerPlayer extends Player {
 
     private static final Logger LOGGER = LogUtils.getLogger();
+
+    // Suki start - per-player view distance
+
+    private static int[] maxViewDistanceDueToTotalViewedChunks = {32, 32};
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static int computeMaxViewDistanceDueToTotalViewedChunks(int type) {
+        int maxTotalChunks = ((type == 0) ? SukiGlobalConfiguration.get().viewDistance.track : SukiGlobalConfiguration.get().viewDistance.see).getMaxTotalChunks();
+        if (maxTotalChunks == -1) return -1;
+        int candidateViewDistance = maxViewDistanceDueToTotalViewedChunks[type];
+        int[] playerViewDistances = new int[MinecraftServer.getServer().getPlayerCount()];
+        int playerI = 0;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            playerViewDistances[playerI] = player.getViewDistance(type);
+            playerI++;
+        }
+        for (boolean increase : new boolean[] {false, true}) {
+            int chunks = 0;
+            for (int playerViewDistance : playerViewDistances) {
+                // We assume the worst: that if the player's view distance is equal to the current limit, that it will definitely grow to the new limit
+                int playerViewDistanceUnderCandidateAssumption = playerViewDistance >= ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] ? candidateViewDistance : Math.min(candidateViewDistance, playerViewDistance);
+                int playerViewDimensionUnderCandidateAssumption = playerViewDistanceUnderCandidateAssumption * 2 + 1;
+                chunks += playerViewDimensionUnderCandidateAssumption * playerViewDimensionUnderCandidateAssumption;
+            }
+            if (candidateViewDistance > 2 && (chunks > maxTotalChunks || candidateViewDistance > 32)) {
+                candidateViewDistance--;
+                if (increase) {
+                    continue;
+                }
+            } else {
+                candidateViewDistance++;
+                if (!increase) {
+                    continue;
+                }
+            }
+        }
+        return candidateViewDistance;
+    }
+
+    /**
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static void processMaxViewDistanceDueToTotalViewedChunksChange(int oldMaxViewDistanceDueToTotalViewedChunks, int type) {
+        if (oldMaxViewDistanceDueToTotalViewedChunks == ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]) return;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            player.viewDistanceMayHaveChanged(type);
+        }
+    }
+
+    public static void maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(0);
+    }
+
+    public static void maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(1);
+    }
+
+    /**
+     * Is called only from ServerPlayer.processViewDistanceChange(type)
+     */
+    private static void maxViewDistanceDueToTotalViewedChunksMayHaveChanged(int type) {
+        int oldMaxViewDistanceDueToTotalViewedChunks = ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type];
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] = ServerPlayer.computeMaxViewDistanceDueToTotalViewedChunks(type);
+        ServerPlayer.processMaxViewDistanceDueToTotalViewedChunksChange(oldMaxViewDistanceDueToTotalViewedChunks, type);
+    }
+
+    private final int getWorldSeeViewDistance() { return this.getLevel().getChunkSource().chunkMap.getVanillaWorldViewDistance() - 1; } // Paper - placeholder
+
+    private final int getWorldTrackViewDistance() {
+        return this.getWorldSeeViewDistance();
+    }
+
+    private final int getWorldLoadViewDistance() {
+        return this.getWorldSeeViewDistance() + 1;
+    }
+
+    private final int getWorldViewDistance(int type) {
+        switch (type) {
+            case 0: return this.getWorldTrackViewDistance();
+            case 1: return this.getWorldSeeViewDistance();
+            case 2: return this.getWorldLoadViewDistance();
+        }
+        throw new IllegalArgumentException();
+    }
+
+    private @Nullable Integer @NotNull [] viewDistances = {null, null, null};
+
+    public final int getTrackViewDistance() {
+        return this.getViewDistance(0);
+    }
+
+    public final int getSeeViewDistance() {
+        return this.getViewDistance(1);
+    }
+
+    public final int getLoadViewDistance() {
+        return this.getViewDistance(2);
+    }
+
+    public final int getTickingViewDistance() {
+        int loadViewDistanceMinusOne = this.getLoadViewDistance() - 1;
+        ServerLevel level = this.getLevel();
+        if (level != null) {
+            PlayerChunkLoader playerChunkLoader = level.getChunkSource().chunkMap.playerChunkManager;
+            PlayerChunkLoader.PlayerLoaderData data = playerChunkLoader.getData(this);
+            if (data != null && data.tickViewDistance != -1) {
+                return Math.min(loadViewDistanceMinusOne, data.tickViewDistance);
+            }
+            return Math.min(loadViewDistanceMinusOne, playerChunkLoader.getTickDistance());
+        }
+        return loadViewDistanceMinusOne;
+    }
+
+    private final int getViewDistance(int type) {
+        if (this.viewDistances[type] == null) {
+            this.viewDistanceMayHaveChanged(type);
+        }
+        return this.viewDistances[type];
+    }
+
+    public final void trackViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(0);
+    }
+
+    public final void seeViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(1);
+    }
+
+    public final void loadViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(2);
+    }
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final int computeViewDistance(int type) {
+        switch (type) {
+            case 0: {
+                this.level.timings.computeTrackViewDistance.startTiming();
+
+                // Limit by world view distance
+                int trackViewDistance = this.getWorldTrackViewDistance();
+                // Limit by see view distance
+                trackViewDistance = Math.min(trackViewDistance, this.getSeeViewDistance());
+                if (this.getLevel().sukiConfig().viewDistance.track.getPerPlayer()) {
+                    // Limit by world max track view distance
+                    int levelMaxTrackViewDistance = this.getLevel().sukiConfig().viewDistance.track.getMax();
+                    if (levelMaxTrackViewDistance != -1) {
+                        trackViewDistance = Math.min(trackViewDistance, levelMaxTrackViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().sukiConfig().viewDistance.track.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            trackViewDistance = Math.min(trackViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total tracked chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    trackViewDistance = Math.min(trackViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                trackViewDistance = Mth.clamp(trackViewDistance, 2, 32);
+
+                this.level.timings.computeTrackViewDistance.stopTiming();
+
+                return trackViewDistance;
+            }
+            case 1: {
+                this.level.timings.computeSeeViewDistance.startTiming();
+
+                // Limit by world view distance
+                int seeViewDistance = this.getWorldSeeViewDistance();
+                if (this.getLevel().sukiConfig().viewDistance.see.getPerPlayer()) {
+                    // Limit by world max see view distance
+                    int levelMaxSeeViewDistance = this.getLevel().sukiConfig().viewDistance.see.getMax();
+                    if (levelMaxSeeViewDistance != -1) {
+                        seeViewDistance = Math.min(seeViewDistance, levelMaxSeeViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().sukiConfig().viewDistance.see.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            seeViewDistance = Math.min(seeViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total seen chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    seeViewDistance = Math.min(seeViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                seeViewDistance = Mth.clamp(seeViewDistance, 2, 32);
+
+                this.level.timings.computeSeeViewDistance.stopTiming();
+
+                return seeViewDistance;
+            }
+            case 2: {
+                this.level.timings.computeLoadViewDistance.startTiming();
+
+                // Limit by world view distance
+                int loadViewDistance = this.getWorldLoadViewDistance();
+                if (this.getLevel().sukiConfig().viewDistance.load.getPerPlayer()) {
+                    // Limit by world max load view distance
+                    int levelMaxLoadViewDistance = this.getLevel().sukiConfig().viewDistance.load.getMax();
+                    if (levelMaxLoadViewDistance != -1) {
+                        loadViewDistance = Math.min(loadViewDistance, levelMaxLoadViewDistance);
+                    }
+                    // Limit by see view distance
+                    if (this.getLevel().sukiConfig().viewDistance.load.getLimitBySeeViewDistance()) {
+                        loadViewDistance = Math.min(loadViewDistance, this.getSeeViewDistance() + 1);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().sukiConfig().viewDistance.load.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            loadViewDistance = Math.min(loadViewDistance, this.clientViewDistance + 2);
+                        }
+                    }
+                }
+                // Clamp to possible values
+                loadViewDistance = Mth.clamp(loadViewDistance, 3, 33);
+
+                this.level.timings.computeLoadViewDistance.stopTiming();
+
+                return loadViewDistance;
+            }
+        }
+        throw new IllegalArgumentException();
+    }
+
+    /**
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final void processViewDistanceChange(@Nullable Integer oldViewDistance, int type) {
+
+        int newViewDistance = this.viewDistances[type];
+        if (oldViewDistance != null && oldViewDistance == newViewDistance) return;
+
+        switch (type) {
+            case 0: {
+                this.level.timings.processTrackViewDistanceChange.startTiming();
+                // Update track view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                this.level.timings.processTrackViewDistanceChange.stopTiming();
+                break;
+            }
+            case 1: {
+                this.level.timings.processSeeViewDistanceChange.startTiming();
+                // Update track view distance
+                this.trackViewDistanceMayHaveChanged();
+                // Update load view distance
+                this.loadViewDistanceMayHaveChanged();
+                // Update see view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                this.level.timings.processSeeViewDistanceChange.stopTiming();
+                break;
+            }
+        }
+
+    }
+
+    private final void viewDistanceMayHaveChanged(int type) {
+        Timing timing = switch (type) {
+            case 0 -> this.level.timings.trackViewDistanceMayHaveChanged;
+            case 1 -> this.level.timings.seeViewDistanceMayHaveChanged;
+            case 2 -> this.level.timings.loadViewDistanceMayHaveChanged;
+            default -> null;
+        };
+        timing.startTiming();
+        Integer oldViewDistance = this.viewDistances[type];
+        this.viewDistances[type] = this.computeViewDistance(type);
+        this.processViewDistanceChange(oldViewDistance, type);
+        timing.stopTiming();
+    }
+
+    // Suki end - per-player view distance
+
     public long lastSave = MinecraftServer.currentTick; // Paper
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_XZ = 32;
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_Y = 10;
@@ -1984,6 +2254,11 @@ public class ServerPlayer extends Player {
         this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE).set(this.adventure$locale);
         // Paper end
         this.clientViewDistance = packet.getAcceptableViewDistance(); // Suki - allow invalid client view distance
+        // Suki start - per-player view distance
+        this.trackViewDistanceMayHaveChanged();
+        this.seeViewDistanceMayHaveChanged();
+        this.loadViewDistanceMayHaveChanged();
+        // Suki end - per-player view distance
         // CraftBukkit end
         this.chatVisibility = packet.chatVisibility();
         this.canChatColor = packet.chatColors();
@@ -2244,27 +2519,37 @@ public class ServerPlayer extends Player {
         return true; // Paper
     }
 
-    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket) {
+    // Suki start - per-player track and see view distance
+
+    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket, boolean concernsTracking) {
         this.connection.send(chunkDataPacket);
-        // Paper start
-        if(io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0){
-            new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+        if (concernsTracking) {
+            // Paper start
+            if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            }
+            // Paper end
         }
-        // Paper end
     }
 
-    public void untrackChunk(ChunkPos chunkPos) {
+    public void untrackChunk(ChunkPos chunkPos, boolean concernsTracking) {
         if (this.isAlive()) {
-            this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
-            // Paper start
-            if(io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0){
-                new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            if (!concernsTracking) {
+                this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
+            }
+            if (concernsTracking) {
+                // Paper start
+                if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                    new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+                }
+                // Paper end
             }
-            // Paper end
         }
 
     }
 
+    // Suki end - per-player track and see view distance
+
     public SectionPos getLastSectionPos() {
         return this.lastSectionPos;
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index b211fbdda02b824b98061f8fc498e0ae6b6baa2e..709a2496837101dc890af560c90798efc52a7dba 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -24,7 +24,6 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
 import java.util.function.Function;
-import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
@@ -99,6 +98,7 @@ import net.minecraft.world.scores.Team;
 import org.slf4j.Logger;
 
 // CraftBukkit start
+import com.google.common.base.Predicate;
 import java.util.stream.Collectors;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerLevel;
@@ -113,7 +113,6 @@ import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.entity.Player;
 import org.bukkit.event.player.PlayerChangedWorldEvent;
 import org.bukkit.event.player.PlayerJoinEvent;
@@ -277,7 +276,8 @@ public abstract class PlayerList {
         boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
 
         // Spigot - view distance
-        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat(), player.getLastDeathLocation())); // Paper - replace old player chunk management
+        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), player.getSeeViewDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat(), player.getLastDeathLocation())); // Paper - replace old player chunk management // Suki - per-player view distance
+
         player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
         playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -972,7 +972,7 @@ public abstract class PlayerList {
         // CraftBukkit start
         LevelData worlddata = worldserver1.getLevelData();
         if (!entityplayer.smoothWorldTeleport) entityplayer1.connection.send(new ClientboundRespawnPacket(worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), entityplayer1.gameMode.getGameModeForPlayer(), entityplayer1.gameMode.getPreviousGameModeForPlayer(), worldserver1.isDebug(), worldserver1.isFlat(), flag, entityplayer1.getLastDeathLocation())); // Slice
-        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())); // Spigot // Paper - replace old player chunk management
+        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(entityplayer1.getSeeViewDistance())); // Spigot // Paper - replace old player chunk management // Suki - per-player see view distance
         entityplayer1.connection.send(new ClientboundSetSimulationDistancePacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance())); // Spigot // Paper - replace old player chunk management
         entityplayer1.spawnIn(worldserver1);
         entityplayer1.unsetRemoved();
@@ -1550,7 +1550,7 @@ public abstract class PlayerList {
             ServerLevel worldserver = (ServerLevel) iterator.next();
 
             if (worldserver != null) {
-                worldserver.getChunkSource().setViewDistance(viewDistance);
+                worldserver.getChunkSource().setVanillaWorldViewDistance(viewDistance); // Suki - per-player view distance
             }
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index 47d6236daca806878399890a8d08e55233f19fd9..bc4ec521c3d6854d8c6922f26d283dfb9665f2ea 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -5,6 +5,8 @@ import com.mojang.logging.LogUtils;
 import java.util.Iterator;
 import java.util.List;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.nbt.CompoundTag;
@@ -677,7 +679,7 @@ public class EnderDragon extends Mob implements Enemy {
                 // this.world.b(1028, this.getChunkCoordinates(), 0);
                 //int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (net.minecraft.server.level.ServerPlayer player : (List<net.minecraft.server.level.ServerPlayer>) ((ServerLevel)level).players()) {
-                    final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - route to player chunk loader
+                    final int viewDistance = level.sukiConfig().viewDistance.ifCanSeeButNotTracking.sendEnderDragonSpawnSound ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - route to player chunk loader // Suki - per-player track and see view distance
                     double deltaX = this.getX() - player.getX();
                     double deltaZ = this.getZ() - player.getZ();
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index 7709643fc5212bfff93eeba1b0e2b0d0ed12ca83..5280345305f174feaa6a4e45e1feaf353c1a2b33 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -5,6 +5,8 @@ import java.util.EnumSet;
 import java.util.List;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.world.BossEvent;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.damagesource.DamageSource;
@@ -47,9 +49,7 @@ import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
-import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerBossEvent;
-import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
@@ -278,7 +278,7 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
                     // this.world.globalLevelEvent(1023, new BlockPosition(this), 0);
                     //int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                     for (ServerPlayer player : (List<ServerPlayer>)this.level.players()) { // Paper
-                        final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - route to player chunk loader
+                        final int viewDistance = this.level.sukiConfig().viewDistance.ifCanSeeButNotTracking.sendWitherSpawnSound ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - route to player chunk loader // Suki - per-player track and see view distance
                         double deltaX = this.getX() - player.getX();
                         double deltaZ = this.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/item/EnderEyeItem.java b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
index fa1ff2e79954089552974cefedfcbff2225738ec..318fede4832b2e93472f674659ea12d5ac5de7c0 100644
--- a/src/main/java/net/minecraft/world/item/EnderEyeItem.java
+++ b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
@@ -25,6 +25,7 @@ import net.minecraft.world.level.block.state.pattern.BlockPattern;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.HitResult;
+import org.sucraft.suki.configuration.SukiGlobalConfiguration;
 
 public class EnderEyeItem extends Item {
 
@@ -65,7 +66,7 @@ public class EnderEyeItem extends Item {
                     //int viewDistance = world.getCraftServer().getViewDistance() * 16; // Paper - apply view distance patch
                     BlockPos soundPos = blockposition1.offset(1, 0, 1);
                     for (ServerPlayer player : world.getServer().getPlayerList().players) {
-                        final int viewDistance = io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player); // Paper - apply view distance patch
+                        final int viewDistance = world.sukiConfig().viewDistance.ifCanSeeButNotTracking.sendEndPortalFillSound ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - apply view distance patch // Suki - per-player track and see view distance
                         double deltaX = soundPos.getX() - player.getX();
                         double deltaZ = soundPos.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 76832f628c4f0145003041f48a921521983ecc51..e83ceabf4560c78cc3b711320bb8531c39632819 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -739,7 +739,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 this.sendBlockUpdated(blockposition, iblockdata1, iblockdata, i);
                 // Paper start - per player view distance - allow block updates for non-ticking chunks in player view distance
                 // if copied from above
-            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.broadcastMap.getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.getBroadcastMap(true).getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management // Suki - per-player track and see view distance
                 ((ServerLevel)this).getChunkSource().blockChanged(blockposition);
                 // Paper end - per player view distance
             }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index b3f8de20eb09547672218c62817759d03461922d..94cf9e5ba69fcf36d03d7e17792282357c374bb3 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -235,7 +235,7 @@ public class LevelChunk extends ChunkAccess {
         // this code handles the chunk sending
         if (!areNeighboursLoaded(bitsetBefore, 1) && areNeighboursLoaded(bitsetAfter, 1)) {
             // Paper start - replace old player chunk loading system
-            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z)) {
+            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z, false)) { // Suki - per-player track and see view distance
                 // the post processing is expensive, so we don't want to run it unless we're actually near
                 // a player.
                 chunkProviderServer.mainThreadProcessor.execute(() -> {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 1b6ae90acffa06502902e11473b65c8431616b05..5eac5eb8b57a33113ba4ce747e66c461f1230163 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -5,6 +5,7 @@ import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.datafixers.util.Pair;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -21,7 +22,6 @@ import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.ExecutionException;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import net.minecraft.core.BlockPos;
@@ -43,7 +43,6 @@ import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.level.Ticket;
 import net.minecraft.server.level.TicketType;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.tags.TagKey;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.Unit;
 import net.minecraft.world.entity.EntityType;
@@ -115,7 +114,6 @@ import org.bukkit.entity.TippedArrow;
 import org.bukkit.entity.Trident;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.event.weather.LightningStrikeEvent;
-import org.bukkit.event.world.SpawnChangeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 import org.bukkit.generator.BiomeProvider;
 import org.bukkit.generator.BlockPopulator;
@@ -498,27 +496,26 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public boolean refreshChunk(int x, int z) {
         ChunkHolder playerChunk = this.world.getChunkSource().chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
         if (playerChunk == null) return false;
-
         // Paper start - rewrite player chunk loader
         net.minecraft.world.level.chunk.LevelChunk chunk = playerChunk.getSendingChunk();
         if (chunk == null) {
             return false;
         }
         // Paper end - rewrite player chunk loader
-                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false);
-                if (playersInRange.isEmpty()) return true; // Paper - rewrite player chunk loader
-
-                // Paper start - Anti-Xray - Bypass
-                Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
-                for (ServerPlayer player : playersInRange) {
-                    if (player.connection == null) continue;
-
-                    Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-                    player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
-                        return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
-                    }));
-                    // Paper end
-                }
+        List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false, !this.getHandle().sukiConfig().viewDistance.ifCanSeeButNotTracking.sendChunkRefresh); // Suki - per-player track and see view distance
+        if (playersInRange.isEmpty()) return true;
+
+        // Paper start - Anti-Xray - Bypass
+        Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
+        for (ServerPlayer player : playersInRange) {
+            if (player.connection == null) continue;
+
+            Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
+            player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
+                return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
+            }));
+            // Paper end
+        }
         // Paper - rewrite player chunk loader
 
         return true;
@@ -2267,7 +2264,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance(); // Paper - replace old player chunk management
+        return getHandle().getChunkSource().chunkMap.getVanillaWorldViewDistance(); // Paper - replace old player chunk management // Suki - per-player view distance
     }
 
     @Override
@@ -2283,7 +2280,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
         }
         net.minecraft.server.level.ChunkMap chunkMap = getHandle().getChunkSource().chunkMap;
-        chunkMap.setViewDistance(viewDistance);
+        chunkMap.setVanillaWorldViewDistance(viewDistance); // Suki - per-player view distance
         // Paper end - replace old player chunk management
     }
 
@@ -2311,12 +2308,15 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getSendViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(); // Paper - replace old player chunk management
+        // Suki start - per-player view distance
+//        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(); // Paper - replace old player chunk management
+        return this.getViewDistance() - 1;
+        // Suki end - per-player view distance
     }
 
     @Override
     public void setSendViewDistance(int viewDistance) {
-        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance); // Paper - replace old player chunk management
+//        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance); // Paper - replace old player chunk management // Suki - per-player view distance
     }
     // Paper end - view distance api
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 60c37b0e71dd2b1b859d23a49f218142d2a92485..a75c1d567e44e5a1087823bcc652228e34bb34e6 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -541,26 +541,28 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
     }
 
+    // Suki start - per-player view distance
     // Paper start - implement view distances
     @Override
     public int getViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
-        }
-        return data.getTargetNoTickViewDistance();
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
+//        }
+//        return data.getTargetNoTickViewDistance();
+        return this.getLoadViewDistance();
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetNoTickViewDistance(viewDistance);
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetNoTickViewDistance(viewDistance);
     }
 
     @Override
@@ -586,35 +588,53 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getNoTickViewDistance() {
-        return this.getViewDistance();
+//        return this.getViewDistance();
+        return this.getLoadViewDistance();
     }
 
     @Override
     public void setNoTickViewDistance(int viewDistance) {
-        this.setViewDistance(viewDistance);
+//        this.setViewDistance(viewDistance);
     }
 
     @Override
     public int getSendViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+        return this.getSeeViewDistance();
     }
 
     @Override
     public void setSendViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetSendViewDistance(viewDistance);
+    }
 
-        data.setTargetSendViewDistance(viewDistance);
+    @Override
+    public int getTrackViewDistance() {
+        return this.getHandle().getTrackViewDistance();
+    }
+
+    @Override
+    public int getSeeViewDistance() {
+        return this.getHandle().getSeeViewDistance();
+    }
+
+    @Override
+    public int getLoadViewDistance() {
+        return this.getHandle().getLoadViewDistance();
     }
     // Paper end - implement view distances
+    // Suki end - per-player view distance
 
     @Override
     public <T> T getClientOption(com.destroystokyo.paper.ClientOption<T> type) {
diff --git a/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java b/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
index 5a1e50c3b65be575ab24bb04d7b0162b2d32dcad..99ee7401b4c9742389d1f1536e7f111a860391ee 100644
--- a/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
+++ b/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
@@ -4,6 +4,7 @@ package org.sucraft.suki.configuration;
 
 import io.papermc.paper.configuration.Configuration;
 import io.papermc.paper.configuration.ConfigurationPart;
+import net.minecraft.server.level.ServerPlayer;
 import org.spongepowered.configurate.objectmapping.meta.Setting;
 
 @SuppressWarnings({"CanBeFinal", "FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic"})
@@ -104,7 +105,7 @@ public class SukiGlobalConfiguration extends ConfigurationPart {
 
     // Suki end - no signed chat
 
-    // Suki start - allow invalid client view distance
+    // Suki start - allow invalid client view distance, per-player track and see view distance
 
     public ViewDistance viewDistance;
 
@@ -112,9 +113,57 @@ public class SukiGlobalConfiguration extends ConfigurationPart {
 
         public boolean allowInvalidClientViewDistance = false;
 
+        public Track track;
+
+        public class Track extends TrackOrSee {
+
+            @Override
+            protected void onMaxTotalChunksChanged() {
+                ServerPlayer.maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged();
+            }
+
+        }
+
+        public See see;
+
+        public class See extends TrackOrSee {
+
+            @Override
+            protected void onMaxTotalChunksChanged() {
+                ServerPlayer.maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged();
+            }
+
+        }
+
+        public abstract class TrackOrSee extends ConfigurationPart {
+
+            /**
+             * -1 indicates no limit
+             *
+             * @deprecated Because this variable should not be used:
+             * use getMaxTotalChunks and setMaxTotalChunks instead
+             */
+            @Deprecated
+            public int maxTotalChunks = -1;
+
+            public int getMaxTotalChunks() {
+                return maxTotalChunks;
+            }
+
+            protected abstract void onMaxTotalChunksChanged();
+
+            public void setMaxTotalChunks(int maxTotalChunks) {
+                if (this.maxTotalChunks != maxTotalChunks) {
+                    this.maxTotalChunks = maxTotalChunks;
+                    onMaxTotalChunksChanged();
+                }
+            }
+
+        }
+
     }
 
-    // Suki end - allow invalid client view distance
+    // Suki end - allow invalid client view distance, per-player track and see view distance
 
     // Suki start - configurable keep-alive
 
diff --git a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
index b423c6df22aa995517234164b4222bedce4c2845..f5b51d75d57a5ede752b4b34af1f7242dcf226c1 100644
--- a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
+++ b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
@@ -9,6 +9,9 @@ import io.papermc.paper.configuration.NestedSetting;
 import io.papermc.paper.configuration.PaperConfigurations;
 import it.unimi.dsi.fastutil.Pair;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.slf4j.Logger;
 import org.spigotmc.SpigotWorldConfig;
 import org.spongepowered.configurate.objectmapping.meta.Setting;
@@ -401,5 +404,160 @@ public class SukiWorldConfiguration extends ConfigurationPart {
 
     // Suki end - more entity activation configuration
 
+    // Suki start - per-player view distance
+
+    public ViewDistance viewDistance;
+
+    public class ViewDistance extends ConfigurationPart {
+
+        public Track track;
+
+        public class Track extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.trackViewDistanceMayHaveChanged();
+            }
+
+        }
+
+        public See see;
+
+        public class See extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.seeViewDistanceMayHaveChanged();
+            }
+
+        }
+
+        public Load load;
+
+        public class Load extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.loadViewDistanceMayHaveChanged();
+            }
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use getLimitBySeeViewDistance and setLimitBySeeViewDistance instead
+             */
+            @Deprecated
+            public boolean limitBySeeViewDistance = false;
+
+            public boolean getLimitBySeeViewDistance() {
+                return limitBySeeViewDistance;
+            }
+
+            public void setLimitBySeeViewDistance(boolean limitBySeeViewDistance) {
+                this.limitBySeeViewDistance = limitBySeeViewDistance;
+                updateAllPlayers();
+            }
+
+            /**
+             * In ticks
+             * <br>
+             * A nonpositive integer disables this feature
+             */
+            public transient int printLoadedChunksInterval = -1;
+
+        }
+
+        public abstract class UpdateAllPlayersOnChangeViewDistance extends SpecificDistance {
+
+            protected abstract void updatePlayer(ServerPlayer player);
+
+            protected void updateAllPlayers() {
+                Bukkit.getOnlinePlayers().forEach(player -> updatePlayer(((CraftPlayer) player).getHandle()));
+            }
+
+            @Override
+            protected void onMaxChanged() {
+                updateAllPlayers();
+            }
+
+            @Override
+            protected void onLimitByClientViewDistanceChanged() {
+                updateAllPlayers();
+            }
+
+        }
+
+        public abstract class SpecificDistance extends ConfigurationPart {
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use getPerPlayer instead
+             */
+            @Deprecated
+            public boolean perPlayer = false;
+
+            public boolean getPerPlayer() {
+                return perPlayer;
+            }
+
+            /**
+             * This is only used if perPlayer is true
+             * <br>
+             * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+             * <br>
+             * Valid values are -1,
+             * or an integer in the range [2, 32] for the track and see view distances and in the range [3, 33] for the
+             * load view distance
+             *
+             * @deprecated Because this variable should not be used:
+             * use getMax and setMax instead
+             */
+            @Deprecated
+            public int max = -1;
+
+            public int getMax() {
+                return max;
+            }
+
+            protected abstract void onMaxChanged();
+
+            public void setMax(int max) {
+                this.max = max;
+                onMaxChanged();
+            }
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use getLimitByClientViewDistance and setLimitByClientViewDistance instead
+             */
+            @Deprecated
+            public boolean limitByClientViewDistance = false;
+
+            public boolean getLimitByClientViewDistance() {
+                return limitByClientViewDistance;
+            }
+
+            protected abstract void onLimitByClientViewDistanceChanged();
+
+            public void setLimitByClientViewDistance(boolean limitByClientViewDistance) {
+                this.limitByClientViewDistance = limitByClientViewDistance;
+                onLimitByClientViewDistanceChanged();
+            }
+
+        }
+
+        public IfCanSeeButNotTracking ifCanSeeButNotTracking;
+
+        public class IfCanSeeButNotTracking extends ConfigurationPart {
+
+            public boolean sendChunkRefresh = true;
+            public boolean sendWitherSpawnSound = true;
+            public boolean sendEnderDragonSpawnSound = true;
+            public boolean sendEndPortalFillSound = true;
+            
+        }
+
+    }
+
+    // Suki end - per-player view distance
 
 }
