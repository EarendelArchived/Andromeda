From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Thu, 25 Aug 2022 21:21:08 +0200
Subject: [PATCH] Prevent block update client lag


diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index b9ee63b0ebc4b337f9522cd7dbf1fe52fc0edf46..71b89d84361931fe28f7baa8193302adfcd56fa8 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -940,6 +940,20 @@ public final class PlayerChunkLoader {
             return concernsTracking ? this.sendQueueForTracking : this.sendQueueForSeeing;
         }
 
+        // Suki start - limit packets per tick
+
+        public int getChunksInSendQueueWithinDistance(final boolean concernsTracking, final int maxManhattanDistance) {
+            int count = 0;
+            for (var holder : getSendQueue(concernsTracking)) {
+                if (holder.manhattanDistanceToPlayer <= maxManhattanDistance) {
+                    count++;
+                }
+            }
+            return count;
+        }
+
+        // Suki end - limit packets per tick
+
 //        protected int sendViewDistance = -1;
 //        protected int loadViewDistance = -1;
         public int tickViewDistance = -1;
diff --git a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
index 4a6b624df834217d7305ba42cab78fdf320ec64c..442b42e80ee9001f9610003c3eaeb7f75f782f73 100644
--- a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
+++ b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
@@ -113,8 +113,8 @@ public class ArgumentTypeInfos {
         register(registry, "entity_summon", EntitySummonArgument.class, SingletonArgumentInfo.contextFree(EntitySummonArgument::id));
         register(registry, "dimension", DimensionArgument.class, SingletonArgumentInfo.contextFree(DimensionArgument::dimension));
         register(registry, "time", TimeArgument.class, SingletonArgumentInfo.contextFree(TimeArgument::time));
-        register(registry, "resource_or_tag", fixClassType(ResourceOrTagLocationArgument.class), new ResourceOrTagLocationArgument.Info());
-        register(registry, "resource", fixClassType(ResourceKeyArgument.class), new ResourceKeyArgument.Info());
+        register(registry, "resource_or_tag", fixClassType(ResourceOrTagLocationArgument.class), new ResourceOrTagLocationArgument.Info<>());
+        register(registry, "resource", fixClassType(ResourceKeyArgument.class), new ResourceKeyArgument.Info<>());
         register(registry, "template_mirror", TemplateMirrorArgument.class, SingletonArgumentInfo.contextFree(TemplateMirrorArgument::templateMirror));
         register(registry, "template_rotation", TemplateRotationArgument.class, SingletonArgumentInfo.contextFree(TemplateRotationArgument::templateRotation));
         if (SharedConstants.IS_RUNNING_IN_IDE) {
@@ -126,7 +126,7 @@ public class ArgumentTypeInfos {
     }
 
     private static <T extends ArgumentType<?>> Class<T> fixClassType(Class<? super T> clazz) {
-        return clazz;
+        return (Class<T>) clazz;
     }
 
     public static boolean isClassRecognized(Class<?> clazz) {
@@ -138,7 +138,7 @@ public class ArgumentTypeInfos {
         if (argumentTypeInfo == null) {
             throw new IllegalArgumentException(String.format(Locale.ROOT, "Unrecognized argument type %s (%s)", argumentType, argumentType.getClass()));
         } else {
-            return argumentTypeInfo;
+            return (ArgumentTypeInfo<A, ?>) argumentTypeInfo;
         }
     }
 
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 4bc4cbb55b0a1040788d2e1e41ff58c7c0310292..b4210fc803030b850b999afcac2e50c0dd7e2723 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -30,24 +30,48 @@ import java.util.Queue;
 import java.util.UUID;
 import java.util.concurrent.RejectedExecutionException;
 import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.TreeMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.locks.ReentrantLock;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import net.minecraft.Util;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.SectionPos;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.game.ClientboundPlayerInfoPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
 import net.minecraft.server.RunningOnDifferentThreadException;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.util.Mth;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
 import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;
 
 
 import io.netty.util.concurrent.AbstractEventExecutor; // Paper
+
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     private static final float AVERAGE_PACKETS_SMOOTHING = 0.75F;
@@ -371,6 +395,790 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
     // Paper end
 
+    // Suki start - limit packets per tick
+
+    private final ReentrantLock queuedPacketsLock = new ReentrantLock();
+    private @org.jetbrains.annotations.Nullable Thread extraThreadExecutorThread = null;
+    private @org.jetbrains.annotations.Nullable ExecutorService extraThreadExecutor = null;
+    private ExecutorService getExtraThreadExecutor() {
+        if (extraThreadExecutor == null) {
+            extraThreadExecutor = Executors.newFixedThreadPool(1, runnable -> {
+                extraThreadExecutorThread = new Thread(runnable);
+                extraThreadExecutorThread.setPriority(Thread.NORM_PRIORITY - 1);
+                return extraThreadExecutorThread;
+            });
+        }
+        return extraThreadExecutor;
+    }
+    private long nextQueuedPacketIndex = 0;
+    private final TreeMap<Long, QueuedPacket> queuedPackets = new TreeMap<>();
+    private static final int creditsPerTick = 180;
+    private static final int maxTotalCredits = creditsPerTick * 7;
+    private static final int[] creditCostPerType = {8, 1, 0/* Determined automatically based on creditCostPerType[1]*/, 28};
+    private static final int maxBlocksToCountForSectionUpdateCreditCost = 20;
+    private int creditsForThisTick = maxTotalCredits;
+//    private @org.jetbrains.annotations.Nullable Packet<?> immuneQueuedPacketBeingSent = null;
+    private Long2ObjectMap<QueuedPistonBlockEventPacket> lastPistonBlockEventPacketPerBlockPosKey = new Long2ObjectOpenHashMap<>(64);
+//    private Long2ObjectMap<Int2ObjectMap<QueuedPistonBlockEventPacket>> lastPistonBlockEventPacketPerActionPerBlockPosKey = new Long2ObjectOpenHashMap<>(64);
+    private Long2ObjectMap<QueuedSomeBlocksUpdatePacket> lastSomeBlocksUpdatePacketPerBlockPosKey = new Long2ObjectOpenHashMap<>(256);
+    private Long2ObjectMap<Int2ObjectMap<QueuedBlockUpdatePacket>> lastBlockUpdatePacketPerBlockStatePerBlockPosKey = new Long2ObjectOpenHashMap<>(256);
+    private Long2ObjectMap<QueuedPacket> lastLightUpdatePacketPerChunkPosKey = new Long2ObjectOpenHashMap<>(8);
+
+    private static final int chunkLoadsWaitMaxManhattanDistance = 7;
+    private static final int chunkLoadsWaitMaxInQueueToSend = 0;
+
+    private class QueuedPacket {
+
+        /**b1
+         * How many'th packet this is that has been queued
+         */
+        public final long index;
+        /**
+         * Is null only when this queued packet has been cancelled but the callbacks are non-null
+         */
+        public @org.jetbrains.annotations.Nullable Packet<?> packet;
+        public final @org.jetbrains.annotations.Nullable PacketSendListener callbacks;
+        /**
+         * 0 = ClientboundBlockEventPacket
+         * 1 = ClientboundBlockUpdatePacket
+         * 2 = ClientboundSectionBlockUpdatesPacket
+         * 3 = ClientboundLightUpdatePacket
+         */
+        public final int type;
+
+        QueuedPacket(long index, @NotNull Packet<?> packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks, int type) {
+            this.index = index;
+            this.packet = packet;
+            this.callbacks = callbacks;
+            this.type = type;
+        }
+
+        /**
+         * Calling this will never remove the packet from any 'last packet for position' map because
+         * this must never be called while the packet is the last packet of a type for a position,
+         * because then the packet must not be cancelled
+         */
+        void cancel() {
+            packet = null;
+            if (callbacks == null) {
+                queuedPackets.remove(index);
+            }
+        }
+
+    }
+
+    private class QueuedPistonBlockEventPacket extends QueuedPacket {
+
+        private @org.jetbrains.annotations.Nullable ClientboundBlockEventPacket blockEventPacket;
+        private @org.jetbrains.annotations.Nullable QueuedSomeBlocksUpdatePacket @org.jetbrains.annotations.Nullable [] protectedPackets;
+
+        QueuedPistonBlockEventPacket(long index, @NotNull ClientboundBlockEventPacket packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks, @org.jetbrains.annotations.Nullable QueuedSomeBlocksUpdatePacket @org.jetbrains.annotations.Nullable [] protectedPackets) {
+            super(index, packet, callbacks, 0);
+            this.blockEventPacket = packet;
+            this.protectedPackets = protectedPackets;
+        }
+
+        boolean canBeSafelyCancelledFromQueue(@org.jetbrains.annotations.Nullable Long blockKeyBeingRemovedFrom, @org.jetbrains.annotations.Nullable Integer action) {
+            long blockKey = blockEventPacket.getPos().asLong();
+            if (blockKeyBeingRemovedFrom == null) {
+                if (lastPistonBlockEventPacketPerBlockPosKey.get(blockKey) == this) {
+                    return false;
+                }
+            }
+//            if (action == null) {
+//                var perAction = lastPistonBlockEventPacketPerActionPerBlockPosKey.get(blockKey);
+//                if (perAction != null && perAction.get(blockEventPacket.getB0() + blockEventPacket.getB1() * 2) == this) {
+//                    return false;
+//                }
+//            }
+            return true;
+        }
+
+        @Override
+        void cancel() {
+//            pistonPacketsInQueue--;
+//            if (pistonPacketsInQueue % 100 == 0) {
+//                MinecraftServer.LOGGER.info("Piston packets in queue: " + pistonPacketsInQueue);
+//            }
+//            if (queuedPackets.size() % 1000 == 0) {
+//                MinecraftServer.LOGGER.info("Total in queue: " + queuedPackets.size());
+//            }
+            blockEventPacket = null;
+            super.cancel();
+            // Remove the protection this was giving to any block update packets
+            if (protectedPackets != null) {
+                for (QueuedSomeBlocksUpdatePacket protectedPacket : protectedPackets) {
+                    if (protectedPacket != null) {
+                        protectedPacket.protectingPistonBlockEventPackets.remove(this);
+                        // Remove the previously protected packet if it is no longer protected
+                        if (protectedPacket.canBeSafelyCancelledFromQueue(null, null)) {
+                            protectedPacket.cancel();
+                        }
+                    }
+                }
+            }
+        }
+
+        @Override
+        public String toString() {
+            return index + ":Piston(" + blockEventPacket.getPos().getX() + "," + blockEventPacket.getPos().getY() + "," + blockEventPacket.getPos().getZ() + ")";
+        }
+
+    }
+
+    private class QueuedSomeBlocksUpdatePacket extends QueuedPacket {
+
+        protected @org.jetbrains.annotations.Nullable List<QueuedPistonBlockEventPacket> protectingPistonBlockEventPackets = null;
+
+        QueuedSomeBlocksUpdatePacket(long index, @NotNull Packet<?> packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks, int type) {
+            super(index, packet, callbacks, type);
+        }
+
+        boolean canBeSafelyCancelledFromQueue(@org.jetbrains.annotations.Nullable Long blockKeyBeingRemovedFrom, @org.jetbrains.annotations.Nullable Integer blockStateId) {
+            if (protectingPistonBlockEventPackets != null && !protectingPistonBlockEventPackets.isEmpty()) {
+                return false;
+            }
+            return true;
+        }
+
+        @Override
+        void cancel() {
+            super.cancel();
+        }
+
+    }
+
+    private class QueuedBlockUpdatePacket extends QueuedSomeBlocksUpdatePacket {
+
+        private @org.jetbrains.annotations.Nullable ClientboundBlockUpdatePacket blockUpdatePacket;
+
+        QueuedBlockUpdatePacket(long index, @NotNull ClientboundBlockUpdatePacket packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks) {
+            super(index, packet, callbacks, 1);
+            this.blockUpdatePacket = packet;
+        }
+
+        @Override
+        boolean canBeSafelyCancelledFromQueue(@org.jetbrains.annotations.Nullable Long blockKeyBeingRemovedFrom, @org.jetbrains.annotations.Nullable Integer blockStateId) {
+            long blockKey = blockUpdatePacket.getPos().asLong();
+            if (blockKeyBeingRemovedFrom == null) {
+                if (lastSomeBlocksUpdatePacketPerBlockPosKey.get(blockKey) == this) {
+                    return false;
+                }
+            }
+            if (blockStateId == null) {
+                var perBlockState = lastBlockUpdatePacketPerBlockStatePerBlockPosKey.get(blockKey);
+                if (perBlockState != null && perBlockState.get(Block.BLOCK_STATE_REGISTRY.getId(blockUpdatePacket.blockState)) == this) {
+                    return false;
+                }
+            }
+            return super.canBeSafelyCancelledFromQueue(blockKeyBeingRemovedFrom, blockStateId);
+        }
+
+        void cancel() {
+            this.blockUpdatePacket = null;
+            super.cancel();
+        }
+
+        @Override
+        public String toString() {
+            return index + ":Block(" + blockUpdatePacket.getPos().getX() + "," + blockUpdatePacket.getPos().getY() + "," + blockUpdatePacket.getPos().getZ() + ")";
+        }
+
+    }
+
+    private class QueuedSectionBlocksUpdatePacket extends QueuedSomeBlocksUpdatePacket {
+
+        private @org.jetbrains.annotations.Nullable ClientboundSectionBlocksUpdatePacket sectionBlocksUpdatePacket;
+
+        QueuedSectionBlocksUpdatePacket(long index, @NotNull ClientboundSectionBlocksUpdatePacket packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks) {
+            super(index, packet, callbacks, 2);
+            this.sectionBlocksUpdatePacket = packet;
+        }
+
+        @Override
+        boolean canBeSafelyCancelledFromQueue(@org.jetbrains.annotations.Nullable Long blockKeyBeingRemovedFrom, @org.jetbrains.annotations.Nullable Integer blockStateId) {
+            SectionPos sectionPos = sectionBlocksUpdatePacket.sectionPos;
+            for (short shortRelativePosition : sectionBlocksUpdatePacket.positions) {
+                int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                long blockKey = BlockPos.asLong(x, y, z);
+                if (blockKeyBeingRemovedFrom == null || blockKey != blockKeyBeingRemovedFrom) {
+                    if (lastSomeBlocksUpdatePacketPerBlockPosKey.get(blockKey) == this) {
+                        return false;
+                    }
+                }
+            }
+            return super.canBeSafelyCancelledFromQueue(blockKeyBeingRemovedFrom, blockStateId);
+        }
+
+        void cancel() {
+            this.sectionBlocksUpdatePacket = null;
+            super.cancel();
+        }
+
+        @Override
+        public String toString() {
+            return index + ":Section(" + sectionBlocksUpdatePacket.sectionPos.getX() + "," + sectionBlocksUpdatePacket.sectionPos.getY() + "," + sectionBlocksUpdatePacket.sectionPos.getZ() + ")";
+        }
+
+    }
+
+//    private int pistonPacketsInQueue = 0; // TEMP DEBUG
+
+    private QueuedBlockUpdatePacket processBlockUpdateToQueue(long queuedPacketIndex, ClientboundBlockUpdatePacket blockUpdatePacket, @org.jetbrains.annotations.Nullable PacketSendListener callbacks) {
+        BlockPos blockPos = blockUpdatePacket.getPos();
+        long blockKey = blockPos.asLong();
+        int blockStateId = Block.BLOCK_STATE_REGISTRY.getId(blockUpdatePacket.blockState);
+        // Create the queued packet
+        var queuedBlockUpdatePacket = new QueuedBlockUpdatePacket(queuedPacketIndex, blockUpdatePacket, callbacks);
+        // Replace the last update packet for the position
+        lastSomeBlocksUpdatePacketPerBlockPosKey.compute(blockKey, ($, existingQueuedPacket) -> {
+            if (existingQueuedPacket != null) {
+                // Cancel the existing queued packet if not protected
+                if (existingQueuedPacket.canBeSafelyCancelledFromQueue(blockKey, null)) {
+                    existingQueuedPacket.cancel();
+                }
+            }
+            // Return this new packet so it is now the last update packet for the position
+            return queuedBlockUpdatePacket;
+        });
+        lastBlockUpdatePacketPerBlockStatePerBlockPosKey.computeIfAbsent(blockKey, $ -> new Int2ObjectOpenHashMap<>(2))
+            .compute(blockStateId, ($, existingQueuedPacket) -> {
+                if (existingQueuedPacket != null) {
+                    // Cancel the existing queued packet if not protected
+                    if (existingQueuedPacket.canBeSafelyCancelledFromQueue(blockKey, blockStateId)) {
+                        existingQueuedPacket.cancel();
+                    }
+                }
+                // Return this new packet so it is now the last update packet for the position
+                return queuedBlockUpdatePacket;
+            });
+        return queuedBlockUpdatePacket;
+    }
+
+    /**
+     * Returns true if the packet is allowed to pass because we are sending it after it had been scheduled
+     */
+    private boolean isImmuneOtherwiseQueue(Packet<?> packet, @org.jetbrains.annotations.Nullable PacketSendListener callbacks) {
+
+        if (!this.isConnected()) {
+            return true;
+        }
+
+        var player = this.getPlayer();
+        if (player != null) {
+            var level = player.getLevel();
+            if (level == null) {
+                return true;
+            }
+            if (!level.sukiConfig().preventBlockUpdateClientLag.enabled) {
+                return true;
+            }
+        }
+
+//        if (packet == immuneQueuedPacketBeingSent) {
+//            return true;
+//        }
+        int type;
+        if (packet instanceof ClientboundBlockEventPacket) {
+            type = 0;
+        } else if (packet instanceof ClientboundBlockUpdatePacket) {
+            type = 1;
+        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket) {
+            type = 2;
+        } else if (packet instanceof ClientboundLightUpdatePacket) {
+            type = 3;
+        } else {
+            return true;
+        }
+
+        int creditCost;
+        if (type == 2) {
+            creditCost = creditCostPerType[1] * Math.min(maxBlocksToCountForSectionUpdateCreditCost, ((ClientboundSectionBlocksUpdatePacket) packet).positions.length);
+        } else {
+            creditCost = creditCostPerType[type];
+        }
+
+        queuedPacketsLock.lock();
+        try {
+//            MinecraftServer.LOGGER.info("Start immune base");
+
+            // Check if we have enough credit left, and if so, and no packets are queued, send it right away
+            if (creditsForThisTick >= creditCost && queuedPackets.isEmpty()) {
+
+                boolean canSend = true;
+                // We don't want to send any of these packets if we haven't even sent 9 tracked chunks
+                if (player != null) {
+                    try {
+//                        var level = player.getLevel();
+//                        if (level.getChunkSource().chunkMap.playerChunkManager.getData(player).getChunksInSendQueueWithinDistance(false, chunkLoadsWaitMaxManhattanDistance) >= chunkLoadsWaitMaxInQueueToSend) {
+//                            canSend = false;
+//                        }
+                        if (lastChunkInitializationPacketInTransitKeepaliveIdWhenLastTickingQueuedPackets != null) {
+                            if (player.isChunkInitializationPacketWithKeepaliveIdInTransit(lastChunkInitializationPacketInTransitKeepaliveIdWhenLastTickingQueuedPackets)) {
+                                canSend = false;
+                            }
+                        }
+                    } catch (Exception ignored) {
+                        canSend = false;
+                    }
+                }
+
+                if (canSend) {
+                    // Subtract the credit cost
+                    creditsForThisTick -= creditCost;
+                    // Send the packet
+                    return true;
+                }
+
+            }
+
+            Runnable run = () -> {
+                queuedPacketsLock.lock();
+                try {
+//                    MinecraftServer.LOGGER.info("Start immune exec");
+
+                    long queuedPacketIndex = nextQueuedPacketIndex;
+                    nextQueuedPacketIndex++;
+                    QueuedPacket queuedPacket;
+
+                    if (type == 0) {
+                        ClientboundBlockEventPacket blockEventPacket = (ClientboundBlockEventPacket) packet;
+                        Block block = blockEventPacket.getBlock();
+                        boolean isPiston = block.equals(Blocks.PISTON) || block.equals(Blocks.STICKY_PISTON);
+                        if (isPiston) {
+                            BlockPos blockPos = blockEventPacket.getPos();
+                            long blockKey = blockPos.asLong();
+                            //                    int action = blockEventPacket.getB0() + blockEventPacket.getB1() * 2;
+                            //                    pistonPacketsInQueue++;
+                            //                    if (pistonPacketsInQueue % 100 == 0) {
+                            //                        MinecraftServer.LOGGER.info("Piston packets in queue: " + pistonPacketsInQueue);
+                            //                    }
+                            //                    if (queuedPackets.size() % 1000 == 0) {
+                            //                        MinecraftServer.LOGGER.info("Total in queue: " + queuedPackets.size());
+                            //                    }
+                            // Get the direction of the piston
+                            Direction pistonDirection = switch (blockEventPacket.getB1()) {
+                                case 0 -> Direction.DOWN;
+                                case 1 -> Direction.UP;
+                                case 2 -> Direction.SOUTH;
+                                case 3 -> Direction.WEST;
+                                case 4 -> Direction.NORTH;
+                                case 5 -> Direction.EAST;
+                                default -> Direction.DOWN; // Should not happen
+                            };
+                            // Potentially protect 3 block update packets: the block itself, relative in direction of piston (where head would be if extended) and twice relative in direction of piston (where block would be moved to due to extending)
+                            @org.jetbrains.annotations.Nullable QueuedSomeBlocksUpdatePacket @org.jetbrains.annotations.Nullable [] protectedPackets = null;
+                            for (int blockI = 0; blockI < 3; blockI++) {
+                                // Get the position of the block to protect
+                                BlockPos relativeBlockPos = blockPos;
+                                if (blockI > 0) {
+                                    relativeBlockPos = blockPos.relative(pistonDirection, blockI);
+                                }
+                                // Check if there is a scheduled block update, and if so, protect it
+                                QueuedSomeBlocksUpdatePacket blocksUpdatePacket = lastSomeBlocksUpdatePacketPerBlockPosKey.get(relativeBlockPos.asLong());
+                                if (blocksUpdatePacket != null) {
+                                    // Protect it
+                                    if (protectedPackets == null) {
+                                        protectedPackets = new QueuedSomeBlocksUpdatePacket[3];
+                                    }
+                                    protectedPackets[blockI] = blocksUpdatePacket;
+                                }
+                            }
+                            // Create the queued packet
+                            var queuedPistonBlockEventPacket = new QueuedPistonBlockEventPacket(queuedPacketIndex, blockEventPacket, callbacks, protectedPackets);
+                            queuedPacket = queuedPistonBlockEventPacket;
+                            // Also mark the protected packets as protected by the newly created queued piston packet
+                            if (queuedPistonBlockEventPacket.protectedPackets != null) {
+                                for (QueuedSomeBlocksUpdatePacket protectedPacket : queuedPistonBlockEventPacket.protectedPackets) {
+                                    if (protectedPacket != null) {
+                                        if (protectedPacket.protectingPistonBlockEventPackets == null) {
+                                            protectedPacket.protectingPistonBlockEventPackets = new ArrayList<>(1);
+                                        }
+                                        protectedPacket.protectingPistonBlockEventPackets.add(queuedPistonBlockEventPacket);
+                                    }
+                                }
+                            }
+                            // Replace the last piston packet for the position
+                            lastPistonBlockEventPacketPerBlockPosKey.compute(blockKey, ($, existingQueuedPacket) -> {
+                                if (existingQueuedPacket != null) {
+                                    // CancellastBlockUpdatePacketPerBlockStatePerBlockPosKey the existing queued packet
+                                    if (existingQueuedPacket.canBeSafelyCancelledFromQueue(blockKey, null)) {
+                                        existingQueuedPacket.cancel();
+                                    }
+                                }
+                                // Return this new packet so it is now the last piston packet for the position
+                                return queuedPistonBlockEventPacket;
+                            });
+                            //                    lastPistonBlockEventPacketPerActionPerBlockPosKey.computeIfAbsent(blockKey, $ -> new Int2ObjectOpenHashMap<>(2))
+                            //                        .compute(action, ($, existingQueuedPacket) -> {
+                            //                            if (existingQueuedPacket != null) {
+                            //                                // Cancel the existing queued packet
+                            //                                if (existingQueuedPacket.canBeSafelyCancelledFromQueue(blockKey, action)) {
+                            //                                    existingQueuedPacket.cancel();
+                            //                                }
+                            //                            }
+                            //                            // Return this new packet so it is now the last update packet for the position
+                            //                            return queuedPistonBlockEventPacket;
+                            //                        });
+                        } else {
+                            queuedPacket = new QueuedPacket(queuedPacketIndex, packet, callbacks, type);
+                        }
+                    } else if (type == 1) {
+                        ClientboundBlockUpdatePacket blockUpdatePacket = (ClientboundBlockUpdatePacket) packet;
+                        queuedPacket = processBlockUpdateToQueue(queuedPacketIndex, blockUpdatePacket, callbacks);
+                    } else if (type == 2) {
+                        ClientboundSectionBlocksUpdatePacket sectionBlocksUpdatePacket = (ClientboundSectionBlocksUpdatePacket) packet;
+                        SectionPos sectionPos = sectionBlocksUpdatePacket.sectionPos;
+                        boolean scheduleSeparately = false;
+                        for (short shortRelativePosition : sectionBlocksUpdatePacket.positions) {
+                            int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                            int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                            int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                            long blockKey = BlockPos.asLong(x, y, z);
+                            if (lastSomeBlocksUpdatePacketPerBlockPosKey.containsKey(blockKey)) {
+                                scheduleSeparately = true;
+                                break;
+                            }
+                        }
+                        if (scheduleSeparately) {
+                            // We will schedule the packet as separate block updates
+                            for (int i = 0; i < sectionBlocksUpdatePacket.positions.length; i++) {
+                                short shortRelativePosition = sectionBlocksUpdatePacket.positions[i];
+                                int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                                int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                                int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                                BlockPos blockPos = new BlockPos(x, y, z);
+
+                                if (i > 0) {
+                                    queuedPacketIndex = nextQueuedPacketIndex;
+                                    nextQueuedPacketIndex++;
+                                }
+
+                                // Create and enqueue the individual block update packet
+                                ClientboundBlockUpdatePacket blockUpdatePacket = new ClientboundBlockUpdatePacket(blockPos, sectionBlocksUpdatePacket.states[i]);
+                                queuedPacket = processBlockUpdateToQueue(queuedPacketIndex, blockUpdatePacket, i == sectionBlocksUpdatePacket.positions.length - 1 ? callbacks : null);
+                                queuedPackets.put(queuedPacketIndex, queuedPacket);
+
+                            }
+                            return;
+                        }
+                        // Create the queued packet
+                        var queuedSectionBlocksUpdatePacket = new QueuedSectionBlocksUpdatePacket(queuedPacketIndex, sectionBlocksUpdatePacket, callbacks);
+                        queuedPacket = queuedSectionBlocksUpdatePacket;
+                        // Put as the last update packet for the positions
+                        for (short shortRelativePosition : sectionBlocksUpdatePacket.positions) {
+                            int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                            int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                            int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                            long blockKey = BlockPos.asLong(x, y, z);
+                            lastSomeBlocksUpdatePacketPerBlockPosKey.put(blockKey, queuedSectionBlocksUpdatePacket);
+                        }
+                    } else if (type == 3) {
+                        ClientboundLightUpdatePacket lightUpdatePacket = (ClientboundLightUpdatePacket) packet;
+                        long chunkKey = ChunkPos.asLong(lightUpdatePacket.getX(), lightUpdatePacket.getZ());
+                        // Create the queued packet
+                        queuedPacket = new QueuedPacket(queuedPacketIndex, packet, callbacks, type);
+                        // Replace the last update packet for the position
+                        final var finalQueuedPacket = queuedPacket;
+                        lastLightUpdatePacketPerChunkPosKey.compute(chunkKey, ($, existingQueuedPacket) -> {
+                            if (existingQueuedPacket != null) {
+                                // Cancel the existing queued packet
+                                existingQueuedPacket.cancel();
+                            }
+                            // Return this new packet so it is now the last update packet for the position
+                            return finalQueuedPacket;
+                        });
+                    } else {
+                        queuedPacket = new QueuedPacket(queuedPacketIndex, packet, callbacks, type);
+                    }
+
+                    // Enqueue the new packet
+                    queuedPackets.put(queuedPacketIndex, queuedPacket);
+
+                } finally {
+//                    MinecraftServer.LOGGER.info("Finish immune exec");
+                    queuedPacketsLock.unlock();
+                }
+            };
+            if (Thread.currentThread() == extraThreadExecutorThread) {
+                run.run();
+            } else {
+                getExtraThreadExecutor().submit(run);
+            }
+
+            return false;
+
+        } finally {
+//            MinecraftServer.LOGGER.info("Finish immune base");
+            queuedPacketsLock.unlock();
+        }
+
+    }
+
+    private @NotNull List<@NotNull Object> packetsToSendAndCallbacksToExecuteLater = new ArrayList<>(4);
+    private @Nullable Long lastChunkInitializationPacketInTransitKeepaliveIdWhenLastTickingQueuedPackets = null;
+
+    private void tickQueuedPackets() {
+
+        if (!this.isConnected()) {
+            return;
+        }
+
+        var player = this.getPlayer();
+        if (player != null) {
+            var level = player.getLevel();
+            if (level == null) {
+                return;
+            }
+            if (!level.sukiConfig().preventBlockUpdateClientLag.enabled) {
+                return;
+            }
+        }
+
+        // Skip this tick if we are still waiting for chunks in transit
+        if (player != null) {
+            if (lastChunkInitializationPacketInTransitKeepaliveIdWhenLastTickingQueuedPackets != null) {
+                if (player.isChunkInitializationPacketWithKeepaliveIdInTransit(lastChunkInitializationPacketInTransitKeepaliveIdWhenLastTickingQueuedPackets)) {
+                    return;
+                }
+            }
+        }
+
+        Runnable run = () -> {
+
+            // Update the available credits
+            queuedPacketsLock.lock();
+            try {
+//                MinecraftServer.LOGGER.info("Start tick pre");
+                creditsForThisTick += creditsPerTick;
+                if (creditsForThisTick > maxTotalCredits) {
+                    creditsForThisTick = maxTotalCredits;
+                }
+            } finally {
+//                MinecraftServer.LOGGER.info("Finish tick pre");
+                queuedPacketsLock.unlock();
+            }
+
+            // We don't want to send any of these packets if we haven't even sent 9 tracked chunks
+//            try {
+//                var player = getPlayer();
+//                var level = (ServerLevel) player.getLevel();
+//                if (level.getChunkSource().chunkMap.playerChunkManager.getData(player).getChunksInSendQueueWithinDistance(false, chunkLoadsWaitMaxManhattanDistance) >= chunkLoadsWaitMaxInQueueToSend) {
+//                    return;
+//                }
+//            } catch (Exception ignored) {
+//                return;
+//            }
+
+            @org.jetbrains.annotations.Nullable List<@NotNull Object> packetsToSendAndCallbacksToExecute = null;
+
+            // Send packets while possible
+            keepSendingPackets: while (true) {
+//                MinecraftServer.LOGGER.info("While loop enter");
+                queuedPacketsLock.lock();
+                try {
+//                    MinecraftServer.LOGGER.info("Start tick in");
+
+                    if (creditsForThisTick <= 0 || queuedPackets.isEmpty()) {
+                        break keepSendingPackets;
+                    }
+
+                    QueuedPacket queuedPacket = queuedPackets.firstEntry().getValue();
+
+                    // If this packet was cancelled, execute its callbacks at no credit cost
+                    if (queuedPacket.packet == null) {
+                        if (queuedPacket.callbacks != null) {
+//                            MinecraftServer.LOGGER.info("Start callback");
+                            if (packetsToSendAndCallbacksToExecute == null) {
+                                packetsToSendAndCallbacksToExecute = new ArrayList<>(4);
+                            }
+                            packetsToSendAndCallbacksToExecute.add(queuedPacket.callbacks);
+//                            MinecraftServer.LOGGER.info("Finish callback");
+                        }
+                        queuedPackets.pollFirstEntry();
+                        continue keepSendingPackets;
+                    }
+
+                    // Check if we have enough credit left, otherwise stop sending queued packets
+                    int creditCost;
+                    if (queuedPacket.type == 2) {
+                        creditCost = creditCostPerType[1] * Math.min(maxBlocksToCountForSectionUpdateCreditCost, ((QueuedSectionBlocksUpdatePacket) queuedPacket).sectionBlocksUpdatePacket.positions.length);
+                    } else {
+                        creditCost = creditCostPerType[queuedPacket.type];
+                    }
+                    if (creditsForThisTick < creditCost) {
+                        break;
+                    }
+
+                    queuedPackets.pollFirstEntry();
+
+                    // Subtract the credit cost
+                    creditsForThisTick -= creditCost;
+                    if (queuedPacket.type == 0 && queuedPacket instanceof QueuedPistonBlockEventPacket pistonBlockEventPacket) {
+//                        MinecraftServer.LOGGER.info("Start process 0");
+                        long blockKey = pistonBlockEventPacket.blockEventPacket.getPos().asLong();
+                        // Remove the last packet for the position if this is it
+                        lastPistonBlockEventPacketPerBlockPosKey.compute(blockKey, ($, existingLastPacket) -> {
+                            if (existingLastPacket == queuedPacket) {
+                                return null;
+                            }
+                            return existingLastPacket;
+                        });
+                        //                    lastPistonBlockEventPacketPerActionPerBlockPosKey.computeIfPresent(blockKey, ($, forAction) -> {
+                        //                        int action = pistonBlockEventPacket.blockEventPacket.getB0() + pistonBlockEventPacket.blockEventPacket.getB1() * 2;
+                        //                        forAction.compute(action, ($$, existingLastPacket) -> {
+                        //                            if (existingLastPacket == queuedPacket) {
+                        //                                return null;
+                        //                            }
+                        //                            return existingLastPacket;
+                        //                        });
+                        //                        return forAction.isEmpty() ? null : forAction;
+                        //                    });
+                        //                    pistonPacketsInQueue--;
+                        //                    if (pistonPacketsInQueue % 100 == 0) {
+                        //                        MinecraftServer.LOGGER.info("Piston packets in queue: " + pistonPacketsInQueue);
+                        //                    }
+                        //                    if (queuedPackets.size() % 1000 == 0) {
+                        //                        MinecraftServer.LOGGER.info("Total in queue: " + queuedPackets.size());
+                        //                    }
+//                        MinecraftServer.LOGGER.info("Finish process 0");
+                    } else if (queuedPacket.type == 1 && queuedPacket instanceof QueuedBlockUpdatePacket blockUpdatePacket) {
+//                        MinecraftServer.LOGGER.info("Start process 1");
+                        long blockKey = blockUpdatePacket.blockUpdatePacket.getPos().asLong();
+                        // Remove the last packet for the position if this is it
+                        lastSomeBlocksUpdatePacketPerBlockPosKey.compute(blockKey, ($, existingLastPacket) -> {
+                            if (existingLastPacket == queuedPacket) {
+                                // We must also remove it as being present in the last block keys of the section
+                                return null;
+                            }
+                            return existingLastPacket;
+                        });
+                        lastBlockUpdatePacketPerBlockStatePerBlockPosKey.computeIfPresent(blockKey, ($, forBlockState) -> {
+                            int blockStateId = Block.BLOCK_STATE_REGISTRY.getId(blockUpdatePacket.blockUpdatePacket.getBlockState());
+                            forBlockState.compute(blockStateId, ($$, existingLastPacket) -> {
+                                if (existingLastPacket == queuedPacket) {
+                                    return null;
+                                }
+                                return existingLastPacket;
+                            });
+                            return forBlockState.isEmpty() ? null : forBlockState;
+                        });
+//                        MinecraftServer.LOGGER.info("Finish process 1");
+                    } else if (queuedPacket.type == 2 && queuedPacket instanceof QueuedSectionBlocksUpdatePacket sectionBlocksUpdatePacket) {
+//                        MinecraftServer.LOGGER.info("Start process 2");
+                        SectionPos sectionPos = sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.sectionPos;
+                        // Remove the last packet for the positions if this is it
+                        for (short shortRelativePosition : sectionBlocksUpdatePacket.sectionBlocksUpdatePacket.positions) {
+                            int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                            int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                            int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                            long blockKey = BlockPos.asLong(x, y, z);
+                            lastSomeBlocksUpdatePacketPerBlockPosKey.compute(blockKey, ($, existingLastPacket) -> {
+                                if (existingLastPacket == queuedPacket) {
+                                    return null;
+                                }
+                                return existingLastPacket;
+                            });
+                        }
+//                        MinecraftServer.LOGGER.info("Finish process 2");
+                    } else if (queuedPacket.type == 3) {
+//                        MinecraftServer.LOGGER.info("Start process 3");
+                        var lightUpdatePacket = (ClientboundLightUpdatePacket) queuedPacket.packet;
+                        long chunkKey = ChunkPos.asLong(lightUpdatePacket.getX(), lightUpdatePacket.getZ());
+                        // Remove the last packet for the position if this is it
+                        lastLightUpdatePacketPerChunkPosKey.compute(chunkKey, ($, existingLastPacket) -> {
+                            if (existingLastPacket == queuedPacket) {
+                                return null;
+                            }
+                            return existingLastPacket;
+                        });
+//                        MinecraftServer.LOGGER.info("Finish process 3");
+                    }
+                    if ((queuedPacket.type == 1 || queuedPacket.type == 2) && queuedPacket instanceof QueuedSomeBlocksUpdatePacket someBlocksUpdatePacket) {
+//                        MinecraftServer.LOGGER.info("Start process 1/2 protected");
+                        // Remove any known protections (otherwise this packet instance cannot be garbage collected due to an existing reference in the protecting queued piston packet)
+                        if (someBlocksUpdatePacket.protectingPistonBlockEventPackets != null) {
+                            for (QueuedPistonBlockEventPacket protectingPacket : someBlocksUpdatePacket.protectingPistonBlockEventPackets) {
+                                if (protectingPacket.protectedPackets != null) {
+                                    for (int i = 0; i < protectingPacket.protectedPackets.length; i++) {
+                                        if (protectingPacket.protectedPackets[i] == someBlocksUpdatePacket) {
+                                            protectingPacket.protectedPackets[i] = null;
+                                        }
+                                    }
+                                }
+                            }
+                        }
+//                        MinecraftServer.LOGGER.info("Finish process 1/2 protected");
+                    }
+                    // Send the packet
+                    if (packetsToSendAndCallbacksToExecute == null) {
+                        packetsToSendAndCallbacksToExecute = new ArrayList<>(4);
+                    }
+                    packetsToSendAndCallbacksToExecute.add(queuedPacket);
+
+                } finally {
+//                    MinecraftServer.LOGGER.info("Finish tick in");
+                    queuedPacketsLock.unlock();
+                }
+
+            }
+//            MinecraftServer.LOGGER.info("While loop exit");
+
+            if (packetsToSendAndCallbacksToExecute != null) {
+                packetsToSendAndCallbacksToExecuteLater.addAll(packetsToSendAndCallbacksToExecute);
+            }
+
+        };
+        if (Thread.currentThread() == extraThreadExecutorThread) {
+            run.run();
+        } else {
+            getExtraThreadExecutor().submit(run);
+        }
+
+        @org.jetbrains.annotations.Nullable List<@NotNull Object> packetsToSendAndCallbacksToExecuteNow = null;
+        queuedPacketsLock.lock();
+        try {
+//            MinecraftServer.LOGGER.info("Start get packets");
+            if (!packetsToSendAndCallbacksToExecuteLater.isEmpty()) {
+                packetsToSendAndCallbacksToExecuteNow = packetsToSendAndCallbacksToExecuteLater;
+                packetsToSendAndCallbacksToExecuteLater = new ArrayList<>(4);
+            }
+        } finally {
+//            MinecraftServer.LOGGER.info("Finish get packets");
+            queuedPacketsLock.unlock();
+        }
+
+//            MinecraftServer.LOGGER.info("Start send packets + exec callbacks");
+        if (packetsToSendAndCallbacksToExecuteNow != null) {
+            if (!packetsToSendAndCallbacksToExecuteNow.isEmpty()) {
+                for (Object packetOrCallbacks : packetsToSendAndCallbacksToExecuteNow) {
+                    if (packetOrCallbacks instanceof PacketSendListener) {
+                        this.channel.eventLoop().execute(() -> {
+                            try {
+                                ((PacketSendListener) packetOrCallbacks).onSuccess();
+                            } catch (Exception e) {
+                                LOGGER.warn("An exception occurred while executing the callbacks of a cancelled queued packet:");
+                                e.printStackTrace();
+                            }
+                        });
+                        continue;
+                    }
+                    //                MinecraftServer.LOGGER.info("Start send packet");
+                    QueuedPacket packet = (QueuedPacket) packetOrCallbacks;
+                    this.sendPacket(packet.packet, packet.callbacks, 1);
+                    //                MinecraftServer.LOGGER.info("Finish send packet");
+                }
+                lastChunkInitializationPacketInTransitKeepaliveIdWhenLastTickingQueuedPackets = player.getLastChunkInitializationPacketInTransitKeepaliveId();
+            }
+        }
+//            MinecraftServer.LOGGER.info("Finish send packets + exec callbacks");
+
+    }
+
+    // Suki end - limit packets per tick
+
     public void send(Packet<?> packet) {
         this.send(packet, (PacketSendListener) null);
     }
@@ -410,10 +1218,38 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     private void sendPacket(Packet<?> packet, @Nullable PacketSendListener callbacks) {
+        this.sendPacket(packet, callbacks, 0);
+    }
+    private void sendPacket(Packet<?> packet, @Nullable PacketSendListener callbacks, int immune) {
         // Paper start - add flush parameter
-        this.sendPacket(packet, callbacks, Boolean.TRUE);
+        this.sendPacket(packet, callbacks, Boolean.TRUE, immune);
     }
     private void sendPacket(Packet<?> packet, @Nullable PacketSendListener callbacks, Boolean flushConditional) {
+        this.sendPacket(packet, callbacks, flushConditional, 0);
+    }
+    private void sendPacket(Packet<?> packet, @Nullable PacketSendListener callbacks, Boolean flushConditional, int immune) {
+        // Suki start - limit packets per tick
+        if (immune == 0 && !isImmuneOtherwiseQueue(packet, callbacks)) {
+            return;
+        }
+//        if (packet instanceof ClientboundBlockEventPacket blockEventPacket) {
+//            if (!blockEventPacketsPerTickLimiter.isImmuneOtherwiseAdd(blockEventPacket, callbacks)) {
+//                return;
+//            }
+//        } else if (packet instanceof ClientboundBlockUpdatePacket blockUpdatePacket) {
+//            if (!blockUpdatePacketsPerTickLimiter.isImmuneOtherwiseAdd(blockUpdatePacket, callbacks)) {
+//                return;
+//            }
+//        } else if (packet instanceof ClientboundLightUpdatePacket lightUpdatePacket) {
+//            if (!lightUpdatePacketsPerTickLimiter.isImmuneOtherwiseAdd(lightUpdatePacket, callbacks)) {
+//                return;
+//            }
+//        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket sectionBlocksUpdatePacket) {
+//            if (!sectionBlocksUpdatePacketsPerTickLimiter.isImmuneOtherwiseAdd(sectionBlocksUpdatePacket, callbacks)) {
+//                return;
+//            }
+//        }
+        // Suki end - limit packets per tick
         this.packetWrites.getAndIncrement(); // must be befeore using canFlush
         boolean effectiveFlush = flushConditional == null ? this.canFlush : flushConditional.booleanValue();
         // Suki start - flush after more packets
@@ -582,6 +1418,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static int joinAttemptsThisTick; // Paper
     private static int currTick; // Paper
     public void tick() {
+        this.tickQueuedPackets(); // Suki - limit packets per tick
         this.flushQueue();
         // Paper start
         if (currTick != net.minecraft.server.MinecraftServer.currentTick) {
@@ -644,6 +1481,13 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             }
         });
         queue.clear();
+        // Suki start - limit packets per tick
+        if (extraThreadExecutor != null) {
+            extraThreadExecutor.shutdownNow();
+            extraThreadExecutor = null;
+            extraThreadExecutorThread = null;
+        }
+        // Suki end - limit packets per tick
     }
     // Paper end
     public void disconnect(Component disconnectReason) {
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 652bea6868a03a5315965f79c76172fb9dbb93fb..70ca28f06d0e8541c1130ff7b1b0bce21872b649 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -14,9 +14,11 @@ import net.minecraft.world.level.chunk.LevelChunkSection;
 public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener> {
 
     private static final int POS_IN_SECTION_BITS = 12;
-    private final SectionPos sectionPos;
-    private final short[] positions;
-    private final BlockState[] states;
+    // Suki start - limit packets per tick
+    public final SectionPos sectionPos;
+    public final short[] positions;
+    public final BlockState[] states;
+    // Suki end - limit packets per tick
     private final boolean suppressLightUpdates;
 
     public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section, boolean noLightingUpdates) {
@@ -94,4 +96,5 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     public boolean shouldSuppressLightUpdates() {
         return this.suppressLightUpdates;
     }
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
index 07d96cca04c9658291eea91e7b0a7f5a3fc9882e..e562a768ad400a6dca0f1546fb0dddbe72324eea 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
@@ -8,6 +8,7 @@ import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.item.crafting.Recipe;
+import net.minecraft.world.item.crafting.RecipeSerializer;
 
 public class ClientboundUpdateRecipesPacket implements Packet<ClientGamePacketListener> {
     private final List<Recipe<?>> recipes;
@@ -45,6 +46,6 @@ public class ClientboundUpdateRecipesPacket implements Packet<ClientGamePacketLi
     public static <T extends Recipe<?>> void toNetwork(FriendlyByteBuf buf, T recipe) {
         buf.writeResourceLocation(Registry.RECIPE_SERIALIZER.getKey(recipe.getSerializer()));
         buf.writeResourceLocation(recipe.getId());
-        recipe.getSerializer().toNetwork(buf, recipe);
+        ((RecipeSerializer<T>) recipe.getSerializer()).toNetwork(buf, recipe);
     }
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 325b24b88739c64b2bafec2c30c8d540452bf4d8..eb6cecce28530dc2e003fd7e45f98a322d13b4fa 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -646,6 +646,30 @@ public class ServerPlayer extends Player {
 
     }
 
+    // Suki start - limit packets per tick
+
+    public @Nullable Long getLastChunkInitializationPacketInTransitKeepaliveId() {
+        synchronized (this.networkConstrainedSendingLock) {
+            if (this.chunkInitializationPacketsInTransitKeepaliveIds.isEmpty()) {
+                return null;
+            }
+            return this.chunkInitializationPacketsInTransitKeepaliveIds.getLast().keepaliveId;
+        }
+    }
+
+    public boolean isChunkInitializationPacketWithKeepaliveIdInTransit(long keepaliveId) {
+        synchronized (this.networkConstrainedSendingLock) {
+            for (ChunkPacketInTransit packet : this.chunkInitializationPacketsInTransitKeepaliveIds) {
+                if (packet.keepaliveId == keepaliveId) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    // Suki end - limit packets per tick
+
     // Suki end - network-constrained chunk sending
 
     // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 709a2496837101dc890af560c90798efc52a7dba..f8c2ca4cf83234fd03f16242c1e8e37e7bc742ae 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -25,6 +25,8 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.function.Function;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.chunk.PlayerChunkLoader;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -42,6 +44,7 @@ import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.chat.OutgoingPlayerChatMessage;
 import net.minecraft.network.chat.PlayerChatMessage;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
 import net.minecraft.network.protocol.game.ClientboundChangeDifficultyPacket;
 import net.minecraft.network.protocol.game.ClientboundCustomPayloadPacket;
 import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
@@ -79,6 +82,7 @@ import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.player.ProfilePublicKey;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.biome.BiomeManager;
@@ -1230,7 +1234,7 @@ public abstract class PlayerList {
     }
 
     public void broadcast(@Nullable net.minecraft.world.entity.player.Player player, double x, double y, double z, double distance, ResourceKey<Level> worldKey, Packet<?> packet) {
-        for (int i = 0; i < this.players.size(); ++i) {
+        forEachPlayer: for (int i = 0; i < this.players.size(); ++i) { // Suki - limit packets per tick
             ServerPlayer entityplayer = (ServerPlayer) this.players.get(i);
 
             // CraftBukkit start - Test if player receiving packet can see the source of the packet
@@ -1240,6 +1244,21 @@ public abstract class PlayerList {
             // CraftBukkit end
 
             if (entityplayer != player && entityplayer.level.dimension() == worldKey) {
+                // Suki start - limit packets per tick
+                if (packet instanceof ClientboundBlockEventPacket blockEventPacket) {
+                    var block = blockEventPacket;
+                    if (block.equals(Blocks.PISTON) || block.equals(Blocks.STICKY_PISTON)) {
+                        if (entityplayer.level instanceof ServerLevel serverLevel) {
+                            var chunkPos = new ChunkPos(blockEventPacket.getPos());
+                            PlayerChunkLoader playerChunkLoader = serverLevel.getChunkSource().chunkMap.playerChunkManager;
+                            PlayerChunkLoader.PlayerLoaderData data = playerChunkLoader.getData(entityplayer);
+                            if (!data.hasSentChunk(chunkPos.x, chunkPos.z, true)) {
+                                continue forEachPlayer;
+                            }
+                        }
+                    }
+                }
+                // Suki end - limit packets per tick
                 double d4 = x - entityplayer.getX();
                 double d5 = y - entityplayer.getY();
                 double d6 = z - entityplayer.getZ();
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index f456ad8a74464414f69b616a48ee9a2c1cee4d90..e784f0b6d862b1d981ce7d63dbf7f1e3e21b0923 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -286,6 +286,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                     world.removeBlock(headPos, false);
                 } else {
                     ((ServerLevel)world).getChunkSource().blockChanged(headPos); // ... fix client desync
+                    ((ServerLevel)world).getChunkSource().blockChanged(headPos.relative(enumdirection)); // Suki - limit packets per tick
                 }
                 // Paper end - fix headless pistons breaking blocks
             }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index f25467ad1c5bac7eaef4b63b2845ad04d7c76e4e..3ea5715b065ac0aeea68feadaaf871564d6572ec 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -13,6 +13,8 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.FluidState;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 public class LevelChunkSection {
 
@@ -330,4 +332,5 @@ public class LevelChunkSection {
 
         this.biomes = datapaletteblock;
     }
+
 }
diff --git a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
index 14bee02adbf2322e226bc90c4fb27c70b0a3b844..22fd84b9337af7cda4a225159341d787a81718ad 100644
--- a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
+++ b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
@@ -596,4 +596,16 @@ public class SukiWorldConfiguration extends ConfigurationPart {
 
     // Suki end - bone meal regrows bark
 
+    // Suki start - limit packets per tick
+
+    public PreventBlockUpdateClientLag preventBlockUpdateClientLag;
+
+    public class PreventBlockUpdateClientLag extends ConfigurationPart {
+
+        public boolean enabled = false;
+
+    }
+
+    // Suki end - limit packets per tick
+
 }
