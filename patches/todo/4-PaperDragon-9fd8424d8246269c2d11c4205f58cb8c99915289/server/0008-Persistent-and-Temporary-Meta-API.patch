From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 4 Mar 2013 23:35:02 -0500
Subject: [PATCH] Persistent and Temporary Meta API


diff --git a/src/main/java/com/domnian/paperdragon/api/CraftDragonAPI.java b/src/main/java/com/domnian/paperdragon/api/CraftDragonAPI.java
index 21bd42ff9d3f744ce9eb06d269d13495011a7be3..b11af17efbbff6c519183bec47a18ee4842aa6ac 100644
--- a/src/main/java/com/domnian/paperdragon/api/CraftDragonAPI.java
+++ b/src/main/java/com/domnian/paperdragon/api/CraftDragonAPI.java
@@ -23,6 +23,8 @@
 
 package com.domnian.paperdragon.api;
 
+import com.domnian.paperdragon.api.meta.CraftDAPI_Meta;
+
 public final class CraftDragonAPI extends DragonAPI {
 
     private CraftDragonAPI() {}
@@ -31,6 +33,7 @@ public final class CraftDragonAPI extends DragonAPI {
     static {
         entity = new CraftDAPI_Entity();
         misc = new CraftDAPI_Misc();
+        meta = new CraftDAPI_Meta();
     }
 
 }
diff --git a/src/main/java/com/domnian/paperdragon/api/meta/CraftDAPI_Meta.java b/src/main/java/com/domnian/paperdragon/api/meta/CraftDAPI_Meta.java
new file mode 100644
index 0000000000000000000000000000000000000000..a8b4af50629e45769d37e321b505ce2aa27de88e
--- /dev/null
+++ b/src/main/java/com/domnian/paperdragon/api/meta/CraftDAPI_Meta.java
@@ -0,0 +1,44 @@
+package com.domnian.paperdragon.api.meta;
+
+import com.domnian.paperdragon.api.Vector3i;
+import io.papermc.paper.util.MCUtil;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import org.bukkit.Chunk;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+
+public class CraftDAPI_Meta implements DAPI_Meta {
+
+    @Override
+    @Nullable
+    public PersistentMetaMap getTileEntityMetaMap(@NotNull BlockState blockState) {
+        final CraftBlockState craftBlockState = (CraftBlockState) blockState;
+        final BlockEntity blockEntity = ((CraftWorld) craftBlockState.getWorld()).getHandle().getBlockEntity(MCUtil.toBlockPosition(craftBlockState.getLocation()));
+        return blockEntity != null ? blockEntity.metaMap : null;
+    }
+
+    @Override
+    @Nullable
+    @Contract("_, true -> !null")
+    public PersistentMetaMap getBlockMetaMap(@NotNull Block block, boolean isWrite) {
+        return MetaApiAccessor.getBlockMetaMap(((CraftChunk) block.getChunk()).getHandle(), block.getX(), block.getY(), block.getZ(), isWrite);
+    }
+
+    @Override
+    public Map<Vector3i, PersistentMetaMap> getBlockMetaData(@NotNull Chunk chunk) {
+        return ((CraftChunk) chunk).getHandle().blockMeta;
+    }
+
+    @Override
+    public Map<String, Object> getBlockTempMeta(@NotNull Block block, boolean isWrite) {
+        return MetaApiAccessor.getBlockTempMeta(block, isWrite);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/domnian/paperdragon/api/meta/MetaApiAccessor.java b/src/main/java/com/domnian/paperdragon/api/meta/MetaApiAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..3274118ec25fd9f591faa2dbf48e8512802ab609
--- /dev/null
+++ b/src/main/java/com/domnian/paperdragon/api/meta/MetaApiAccessor.java
@@ -0,0 +1,631 @@
+package com.domnian.paperdragon.api.meta;
+
+import ca.spottedleaf.dataconverter.minecraft.MCVersions;
+import com.mojang.serialization.Dynamic;
+import io.papermc.paper.util.MCUtil;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.BlockPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.DoubleTag;
+import net.minecraft.nbt.FloatTag;
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.LongTag;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.NumericTag;
+import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.datafix.DataFixers;
+import net.minecraft.util.datafix.fixes.References;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.level.storage.PrimaryLevelData;
+import org.bukkit.Bukkit;
+import com.domnian.paperdragon.api.Vector3i;
+import com.domnian.paperdragon.events.BlockWithPersistentMetaClearedEvent;
+import org.bukkit.Location;
+import org.bukkit.block.Block;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.*;
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+
+public final class MetaApiAccessor {
+
+    private static final String META_MAP = "MetaMap";
+    private static final String META_TYPE = "MetaType";
+    private static final String ITEM = "Item";
+    private static final String ENTITY_META = "_EntityMeta";
+    private static final String TILEENTITY_META = "_TileEntityMeta";
+    private static final String WORLD_META = "_WorldMeta";
+    private static final String CHUNK_META = "_ChunkMetaNew";
+    private static final String BLOCK_META_LIST = "_BlockMetaList";
+    private static final String LEGACY_CHUNK_META_LIST = "_ChunkMetaList";
+    private static final String BLOCK_POS = "_BlockPos";
+    private static final String LEGACY_CHUNK_META = "_ChunkMeta";
+
+    private MetaApiAccessor() {
+    }
+
+    /**
+     * Gets the metamap for the specified coords, creating it if it doesnt exists
+     *
+     * @param handle
+     * @param x
+     * @param y
+     * @param z
+     * @return
+     */
+    @Nullable
+    @Contract("_, _, _, _, true -> !null")
+    static PersistentMetaMap getBlockMetaMap(@NotNull LevelChunk handle, int x, int y, int z, boolean isWrite) {
+        BlockPersistentMeta meta = handle.blockMeta;
+        Vector3i coords = new Vector3i(x, y, z);
+        if (!isWrite && !meta.containsKey(coords)) {
+            return null;
+        }
+        PersistentMetaMap ret = meta.get(coords);
+        if (ret == null) {
+            if (isWrite) {
+                ret = new PersistentMetaMap();
+                meta.put(coords, ret);
+            }
+        }
+        return ret;
+    }
+
+    public static void loadEntityMeta(@NotNull Entity entity, @NotNull CompoundTag nbt) {
+        if (nbt.contains(ENTITY_META)) {
+            putAllFromCompound(entity.metaMap, nbt.getCompound(ENTITY_META));
+        }
+    }
+
+    public static void saveEntityMeta(@NotNull Entity entity, @NotNull CompoundTag nbt) {
+        if (!entity.metaMap.isEmpty()) {
+            nbt.put(ENTITY_META, getCompoundFromMetaMap(entity.metaMap));
+        }
+    }
+
+    public static void loadTileEntityMeta(@NotNull BlockEntity tileEntity, @NotNull CompoundTag nbt) {
+        if (nbt.contains(TILEENTITY_META)) {
+            putAllFromCompound(tileEntity.metaMap, nbt.getCompound(TILEENTITY_META));
+        }
+    }
+
+    public static void saveTileEntityMeta(@NotNull BlockEntity blockEntity, @NotNull CompoundTag nbt) {
+        if (!blockEntity.metaMap.isEmpty()) {
+            nbt.put(TILEENTITY_META, getCompoundFromMetaMap(blockEntity.metaMap));
+        }
+    }
+
+    public static void loadWorldMeta(@NotNull PrimaryLevelData world, @NotNull CompoundTag nbt) {
+        if (nbt.contains(WORLD_META)) {
+            CompoundTag nbtmeta = nbt.getCompound(WORLD_META);
+            putAllFromCompound(world.metaMap, nbtmeta);
+        }
+    }
+
+    public static void saveWorldMeta(@NotNull PrimaryLevelData worldData, @NotNull CompoundTag nbt) {
+        if (!worldData.metaMap.isEmpty()) {
+            Tag nbtmeta = getCompoundFromMetaMap(worldData.metaMap);
+            nbt.put(WORLD_META, nbtmeta);
+        }
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     *
+     * @param cmp
+     * @param chunkAccess
+     */
+    public static void saveChunkMetaNbt(@NotNull CompoundTag cmp, @NotNull ChunkAccess chunkAccess) {
+        LevelChunk chunk = null;
+        if (chunkAccess instanceof LevelChunk) {
+            chunk = (LevelChunk) chunkAccess;
+        } else if (chunkAccess instanceof ImposterProtoChunk) {
+            chunk = ((ImposterProtoChunk) chunkAccess).getWrapped();
+        } else if (chunkAccess instanceof ProtoChunk) {
+            saveProtoChunkMetaNbt(cmp, (ProtoChunk) chunkAccess);
+            return;
+        }
+        if (chunk == null) {
+            throw new IllegalArgumentException("Failed to get chunk to save meta for");
+        }
+        saveChunkMetaNbt(cmp, chunk);
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     *
+     * @param cmp
+     * @param chunk
+     */
+    private static void saveChunkMetaNbt(@NotNull CompoundTag cmp, @NotNull LevelChunk chunk) {
+        if (!chunk.chunkMeta.isEmpty()) {
+            cmp.put(CHUNK_META, getCompoundFromMetaMap(chunk.chunkMeta));
+        }
+        if (!chunk.blockMeta.isEmpty()) {
+            ListTag meta = new ListTag();
+            for (Map.Entry<Vector3i, PersistentMetaMap> entry : chunk.blockMeta.entrySet()) {
+                PersistentMetaMap list = entry.getValue();
+                if (!list.isEmpty()) {
+                    CompoundTag pos = serializePos(entry.getKey());
+                    CompoundTag metacmp = getCompoundFromMetaMap(list);
+                    metacmp.put(BLOCK_POS, pos);
+                    meta.add(metacmp);
+                }
+            }
+
+            if (!meta.isEmpty()) {
+                cmp.put(BLOCK_META_LIST, meta);
+            }
+        }
+
+    }
+
+    /**
+     * Saves this protoChunk's Meta Data into NBT
+     *
+     * @param cmp
+     * @param protoChunk
+     */
+    private static void saveProtoChunkMetaNbt(@NotNull CompoundTag cmp, @NotNull ProtoChunk protoChunk) {
+        if (protoChunk.legacyChunkMeta != null) {
+            cmp.put(LEGACY_CHUNK_META, protoChunk.legacyChunkMeta);
+        } else if (protoChunk.legacyChunkMetaList != null) {
+            cmp.put(LEGACY_CHUNK_META_LIST, protoChunk.legacyChunkMetaList);
+        } else {
+            if (protoChunk.chunkMeta != null) {
+                cmp.put(CHUNK_META, protoChunk.chunkMeta);
+            }
+            if (protoChunk.blockMetaList != null) {
+                cmp.put(BLOCK_META_LIST, protoChunk.blockMetaList);
+            }
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     *
+     * @param cmp
+     * @param chunkAccess
+     */
+    public static void loadChunkMetaNbt(@NotNull CompoundTag cmp, @NotNull ChunkAccess chunkAccess) {
+        LevelChunk chunk = null;
+        if (chunkAccess instanceof LevelChunk) {
+            chunk = (LevelChunk) chunkAccess;
+        } else if (chunkAccess instanceof ImposterProtoChunk) {
+            chunk = ((ImposterProtoChunk) chunkAccess).getWrapped();
+        } else if (chunkAccess instanceof ProtoChunk) {
+            loadProtoChunk(cmp, (ProtoChunk) chunkAccess);
+            return;
+        }
+        if (chunk == null) {
+            throw new IllegalArgumentException("Failed to get chunk to load meta for");
+        }
+        loadChunkMetaNbt(cmp, chunk);
+    }
+
+    /**
+     * Save the chunk Meta Data to be loaded later
+     *
+     * @param cmp
+     * @param protoChunk
+     */
+    private static void loadProtoChunk(CompoundTag cmp, ProtoChunk protoChunk) {
+        if (cmp.contains(LEGACY_CHUNK_META)) {
+            protoChunk.legacyChunkMeta = cmp.getCompound(LEGACY_CHUNK_META);
+        } else if (cmp.contains(LEGACY_CHUNK_META_LIST)) {
+            protoChunk.legacyChunkMetaList = cmp.getList(LEGACY_CHUNK_META_LIST, 10);
+        } else {
+            if (cmp.contains(CHUNK_META)) {
+                protoChunk.chunkMeta = cmp.getCompound(CHUNK_META);
+            }
+            if (cmp.contains(BLOCK_META_LIST)) {
+                protoChunk.blockMetaList = cmp.getList(BLOCK_META_LIST, 10);
+            }
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     *
+     * @param cmp
+     * @param chunk
+     */
+    private static void loadChunkMetaNbt(@NotNull CompoundTag cmp, @NotNull LevelChunk chunk) {
+        if (cmp.contains(LEGACY_CHUNK_META)) {
+            loadLegacyChunkMeta(cmp.getCompound(LEGACY_CHUNK_META), chunk);
+        } else if (cmp.contains(LEGACY_CHUNK_META_LIST)) {
+            loadLegacyChunkMetaList(cmp.getList(LEGACY_CHUNK_META_LIST, 10), chunk);
+        } else {
+            if (cmp.contains(CHUNK_META)) {
+                loadChunkMeta(cmp.getCompound(CHUNK_META), chunk);
+            }
+            if (cmp.contains(BLOCK_META_LIST)) {
+                loadBlockMetaList(cmp.getList(BLOCK_META_LIST, 10), chunk);
+            }
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from a ProtoChunk
+     *
+     * @param protoChunk
+     * @param chunk
+     */
+    public static void loadProtoChunkMetaNbt(@NotNull ProtoChunk protoChunk, @NotNull LevelChunk chunk) {
+        if (protoChunk.legacyChunkMeta != null) {
+            loadLegacyChunkMeta(protoChunk.legacyChunkMeta, chunk);
+        } else if (protoChunk.legacyChunkMetaList != null) {
+            loadLegacyChunkMetaList(protoChunk.legacyChunkMetaList, chunk);
+        } else {
+            if (protoChunk.chunkMeta != null) {
+                loadChunkMeta(protoChunk.chunkMeta, chunk);
+            }
+            if (protoChunk.blockMetaList != null) {
+                loadBlockMetaList(protoChunk.blockMetaList, chunk);
+            }
+        }
+    }
+
+    private static void loadLegacyChunkMeta(@NotNull CompoundTag chunkMeta, @NotNull LevelChunk chunk) {
+        for (String key : chunkMeta.getAllKeys()) {
+            CompoundTag e = chunkMeta.getCompound(key);
+            Vector3i vector = deserializeOldLoc(key);
+            if (vector != null) {
+                if (vector.x == 0 && vector.y == -1 && vector.z == 0) {
+                    putAllFromCompound(chunk.chunkMeta, e);
+                } else {
+                    loadBlockMeta(chunk.blockMeta, vector, e);
+                }
+            }
+        }
+    }
+
+    private static void loadLegacyChunkMetaList(@NotNull ListTag chunkMeta, @NotNull LevelChunk chunk) {
+        final int size = chunkMeta.size();
+        for (int i = 0; i < size; i++) {
+            CompoundTag e = chunkMeta.getCompound(i);
+            if (e.contains(BLOCK_POS)) {
+                CompoundTag blockPos = e.getCompound(BLOCK_POS);
+                Vector3i vector = getBlockPosFromCompound(blockPos);
+                if (vector.x == 0 && vector.y == -1 && vector.z == 0) {
+                    putAllFromCompound(chunk.chunkMeta, e);
+                } else {
+                    loadBlockMeta(chunk.blockMeta, vector, e);
+                }
+            }
+        }
+    }
+
+    private static void loadChunkMeta(@NotNull CompoundTag chunkMeta, @NotNull LevelChunk chunk) {
+        putAllFromCompound(chunk.chunkMeta, chunkMeta);
+    }
+
+    private static void loadBlockMetaList(@NotNull ListTag chunkMeta, @NotNull LevelChunk chunk) {
+        final int size = chunkMeta.size();
+        for (int i = 0; i < size; i++) {
+            CompoundTag e = chunkMeta.getCompound(i);
+            if (e.contains(BLOCK_POS)) {
+                loadBlockMeta(chunk.blockMeta, getBlockPosFromCompound(e.getCompound(BLOCK_POS)), e);
+            }
+        }
+    }
+
+    private static void loadBlockMeta(@NotNull BlockPersistentMeta meta, @NotNull Vector3i key, @NotNull CompoundTag e) {
+        PersistentMetaMap map = getMetaMapFromCompound(e);
+        if (!map.isEmpty()) {
+            meta.put(key, map);
+        }
+    }
+
+    @NotNull
+    private static Vector3i getBlockPosFromCompound(@NotNull CompoundTag pos) {
+        return new Vector3i(pos.getInt("x"), pos.getInt("y"), pos.getInt("z"));
+    }
+
+    /**
+     * Converts an Object into NBT
+     *
+     * @param value
+     * @return
+     */
+    @Nullable
+    private static Tag getNbtFromObject(@Nullable Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value instanceof String) {
+            return StringTag.valueOf((String) value);
+        } else if (value instanceof ItemStack || value instanceof org.bukkit.inventory.ItemStack) {
+            ItemStack item;
+            if (value instanceof org.bukkit.inventory.ItemStack) {
+                item = CraftItemStack.asNMSCopy((org.bukkit.inventory.ItemStack) value);
+            } else {
+                item = (ItemStack) value;
+            }
+            if (item == null) {
+                return null;
+            }
+            CompoundTag itemnbt = new CompoundTag();
+            itemnbt.putString(META_TYPE, ITEM);
+            itemnbt.putInt("DataVersion", CraftMagicNumbers.INSTANCE.getDataVersion());
+            return item.save(itemnbt);
+        } else if (value instanceof Long) {
+            return LongTag.valueOf((Long) value);
+        } else if (value instanceof Integer) {
+            return IntTag.valueOf((Integer) value);
+        } else if (value instanceof Double) {
+            return DoubleTag.valueOf((Double) value);
+        } else if (value instanceof Float) {
+            return FloatTag.valueOf((Float) value);
+        } else if (value instanceof PersistentMetaMap) {
+            return getCompoundFromMetaMap((PersistentMetaMap) value);
+        } else if (value instanceof PersistentMetaList) {
+            ListTag list = new ListTag();
+            for (Object obj : (Iterable<?>) value) {
+                Tag add = getNbtFromObject(obj);
+                if (add != null) {
+                    list.add(add);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        }
+
+        return null;
+    }
+
+    /**
+     * Converts NBT into an Object
+     *
+     * @param nbt
+     * @return
+     */
+    @Nullable
+    @SuppressWarnings("RedundantCast")
+    private static Object getObjectFromNbt(@Nullable Tag nbt) {
+        if (nbt == null) {
+            return null;
+        }
+        if (nbt instanceof StringTag) {
+            return (String) ((StringTag) nbt).getAsString();
+            // Redundant casts added to each number so that it will fail to compile
+            // If the method names change for each type. Do not remove.
+        } else if (nbt instanceof IntTag) {
+            return (Integer) ((NumericTag) nbt).getAsInt();
+        } else if (nbt instanceof LongTag) {
+            return (Long) ((NumericTag) nbt).getAsLong();
+        } else if (nbt instanceof FloatTag) {
+            return (Float) ((NumericTag) nbt).getAsFloat();
+        } else if (nbt instanceof DoubleTag) {
+            return (Double) ((NumericTag) nbt).getAsDouble();
+        } else if (nbt instanceof ListTag nbtlist) {
+            if (nbtlist.isEmpty()) {
+                return null;
+            }
+            PersistentMetaList<Object> list = new PersistentMetaList<>();
+            for (Tag tag : nbtlist) {
+                final Object obj = getObjectFromNbt(tag);
+                if (obj != null) {
+                    list.add(obj);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        } else if (nbt instanceof CompoundTag) {
+            CompoundTag cmp = (CompoundTag) nbt.copy();
+            if (cmp.contains(META_TYPE)) {
+                String type = cmp.getString(META_TYPE);
+                cmp.remove(META_TYPE);
+                if (ITEM.equals(type)) {
+                    int version = cmp.contains("DataVersion") ? cmp.getInt("DataVersion") : -1;
+                    if (version == -1) {
+                        cmp = (CompoundTag) DataFixers.getDataFixer().update(References.ITEM_STACK, new Dynamic<>(NbtOps.INSTANCE, cmp), -1, MCVersions.V1_12_2).getValue();
+                        version = MCVersions.V1_12_2;
+                    }
+                    cmp = (CompoundTag) DataFixers.getDataFixer().update(References.ITEM_STACK, new Dynamic<>(NbtOps.INSTANCE, cmp), version, SharedConstants.getCurrentVersion().getWorldVersion()).getValue();
+                    return CraftItemStack.asCraftMirror(ItemStack.of(cmp));
+                } else if (META_MAP.equals(type)) {
+                    final PersistentMetaMap metaMap = getMetaMapFromCompound(cmp);
+                    if (metaMap.isEmpty()) {
+                        return null;
+                    }
+                    return metaMap;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Converts a NBTTagCompound to a MetaMap
+     *
+     * @param cmp
+     * @return
+     */
+    @NotNull
+    private static PersistentMetaMap getMetaMapFromCompound(@NotNull CompoundTag cmp) {
+        PersistentMetaMap map = new PersistentMetaMap();
+        for (Entry<String, Tag> entry : cmp.tags.entrySet()) {
+            final Object metaData = getObjectFromNbt(entry.getValue());
+            if (metaData != null) {
+                map.put(entry.getKey(), metaData);
+            }
+        }
+        return map;
+    }
+
+    private static void putAllFromCompound(@NotNull PersistentMetaMap metaMap, @NotNull CompoundTag cmp) {
+        metaMap.allowAsync = true;
+        for (Entry<String, Tag> entry : cmp.tags.entrySet()) {
+            final Object metaData = getObjectFromNbt(entry.getValue());
+            if (metaData != null) {
+                metaMap.put(entry.getKey(), metaData);
+            }
+        }
+        metaMap.allowAsync = false;
+    }
+
+    /**
+     * Converts a MetaMap into an NBTTagCompount
+     *
+     * @param map
+     * @return
+     */
+    @NotNull
+    private static CompoundTag getCompoundFromMetaMap(@NotNull PersistentMetaMap map) {
+        CompoundTag cmp = new CompoundTag();
+        if (map.isEmpty()) {
+            return cmp;
+        }
+        cmp.putString(META_TYPE, META_MAP);
+        for (Map.Entry<String, Object> entry : map.entrySet()) {
+            Tag add = getNbtFromObject(entry.getValue());
+            if (add != null) {
+                cmp.put(entry.getKey(), add);
+            }
+        }
+        return cmp;
+    }
+
+    /**
+     * Translates BlockPos to a String form
+     *
+     * @param coords
+     * @return
+     */
+    @Nullable
+    @Contract("!null -> !null")
+    private static CompoundTag serializePos(@Nullable Vector3i coords) {
+        if (coords == null) {
+            return null;
+        }
+        CompoundTag cmp = new CompoundTag();
+        cmp.putInt("x", coords.x);
+        cmp.putInt("y", coords.y);
+        cmp.putInt("z", coords.z);
+        return cmp;
+    }
+
+    private static final Pattern COLON_SPLIT = Pattern.compile(":");
+
+    /**
+     * Parses a string into BlockPos
+     *
+     * @param loc
+     * @return
+     */
+    @Nullable
+    private static Vector3i deserializeOldLoc(@Nullable String loc) {
+        if (loc != null) {
+            String[] args = COLON_SPLIT.split(loc, 3);
+            if (args.length == 3) {
+                try {
+                    int x = (int) Math.floor(Float.parseFloat(args[0]));
+                    int y = (int) Math.floor(Float.parseFloat(args[1]));
+                    int z = (int) Math.floor(Float.parseFloat(args[2]));
+                    return new Vector3i(x, y, z);
+                } catch (NumberFormatException ignored) {
+                }
+            }
+        }
+        return null;
+    }
+
+    public static void processSetAir(@NotNull LevelChunk chunk, @NotNull BlockPos pos) {
+        BlockPersistentMeta meta = chunk.blockMeta;
+        Vector3i coords = new Vector3i(pos.getX(), pos.getY(), pos.getZ());
+        if (meta.containsKey(coords)) {
+            new BlockWithPersistentMetaClearedEvent(MCUtil.toLocation(chunk.level, pos).getBlock()).callEvent();
+        }
+    }
+
+    public static void filterTileEntityMeta(@NotNull CompoundTag cmp) {
+        cmp.remove(TILEENTITY_META);
+    }
+
+    public static void reload() {
+        // Players are not guaranteed to be in a chunk if dead
+        for (Player player : Bukkit.getOnlinePlayers()) {
+            player.getTempMeta().clear();
+        }
+        for (ServerLevel serverLevel : MinecraftServer.getServer().getAllLevels()) {
+            reloadChunks(serverLevel.chunkTaskScheduler.chunkHolderManager.getOldChunkHolders());
+        }
+    }
+
+    private static void reloadChunks(@NotNull Collection<ChunkHolder> playerChunks) {
+        for (ChunkHolder playerChunk : playerChunks) {
+            LevelChunk chunk = playerChunk.getFullChunkNowUnchecked();
+            if (chunk == null) {
+                continue;
+            }
+            chunk.chunkTempMeta.clear();
+            chunk.blockTempMeta.clear();
+            chunk.getBukkitChunk().getTempMeta().clear();
+            for (Entity entity : chunk.getChunkHolder().getEntityChunk().getEntityList()) {
+                entity.getBukkitEntity().getTempMeta().clear();
+            }
+        }
+    }
+
+    @Nullable
+    @Contract("_, true -> !null")
+    public static Map<String, Object> getBlockTempMeta(@NotNull Block block, boolean isWrite) {
+        Location loc = block.getLocation();
+        LevelChunk chunk = ((CraftChunk) block.getChunk()).getHandle();
+        Vector3i pos = new Vector3i(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
+        Map<String, Object> map = chunk.blockTempMeta.get(pos);
+        if (map == null) {
+            if (!isWrite) {
+                return null;
+            }
+            map = new HashMap<>(0);
+            chunk.blockTempMeta.put(pos, map);
+        }
+        return map;
+    }
+
+    public static class BlockTempMeta extends HashMap<Vector3i, Map<String, Object>> {
+        public BlockTempMeta() {
+            super(0);
+        }
+
+        public BlockTempMeta(Map<? extends Vector3i, ? extends Map<String, Object>> m) {
+            super(m);
+        }
+
+        public BlockTempMeta clone() {
+            return (BlockTempMeta) new BlockTempMeta(this);
+        }
+    }
+
+    public static class BlockPersistentMeta extends HashMap<Vector3i, PersistentMetaMap> {
+        public BlockPersistentMeta() {
+            super(0);
+        }
+
+        BlockPersistentMeta(Map<? extends Vector3i, ? extends PersistentMetaMap> m) {
+            super(m);
+        }
+
+        public BlockPersistentMeta clone() {
+            return new BlockPersistentMeta(this);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java
index fb42d776f15f735fb59e972e00e2b512c23a8387..89c191903dc84aebe7fb210487734749fe2d8381 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkFullTask.java
@@ -2,6 +2,7 @@ package io.papermc.paper.chunk.system.scheduling;
 
 import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
 import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
 import net.minecraft.server.level.ChunkMap;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.level.chunk.ChunkAccess;
@@ -43,6 +44,7 @@ public final class ChunkFullTask extends ChunkProgressionTask implements Runnabl
                 chunk = new LevelChunk(this.world, protoChunk, (final LevelChunk unused) -> {
                     ChunkMap.postLoadProtoChunk(world, protoChunk.getEntities());
                 });
+                MetaApiAccessor.loadProtoChunkMetaNbt(protoChunk, chunk); // PaperDragon
             }
 
             chunk.setChunkHolder(this.scheduler.chunkHolderManager.getChunkHolder(this.chunkX, this.chunkZ)); // replaces setFullStatus
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
index b1e326cf4f7fe447f81b588dcb0eda9a435e59a8..4c94472b3b83f43d77c005c664e43fc75b08643e 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockEntityDataPacket.java
@@ -2,6 +2,7 @@ package net.minecraft.network.protocol.game;
 
 import java.util.function.Function;
 import javax.annotation.Nullable;
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
 import net.minecraft.nbt.CompoundTag;
@@ -25,6 +26,7 @@ public class ClientboundBlockEntityDataPacket implements Packet<ClientGamePacket
     }
 
     private ClientboundBlockEntityDataPacket(BlockPos pos, BlockEntityType<?> blockEntityType, CompoundTag nbt) {
+        MetaApiAccessor.filterTileEntityMeta(nbt); // PaperDragon
         this.pos = pos;
         this.type = blockEntityType;
         this.tag = nbt.isEmpty() ? null : nbt;
@@ -34,6 +36,7 @@ public class ClientboundBlockEntityDataPacket implements Packet<ClientGamePacket
         this.pos = buf.readBlockPos();
         this.type = buf.readById(Registry.BLOCK_ENTITY_TYPE);
         this.tag = buf.readNbt();
+        MetaApiAccessor.filterTileEntityMeta(this.tag); // PaperDragon
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
index 76b6437a1d807c7e1b673f8feeed1f171ee9a803..07f4295723929bd6a901e423f2a9151bf3480079 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
@@ -1,5 +1,6 @@
 package net.minecraft.network.protocol.game;
 
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
 import com.google.common.collect.Lists;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
@@ -182,6 +183,7 @@ public class ClientboundLevelChunkPacketData {
         static ClientboundLevelChunkPacketData.BlockEntityInfo create(BlockEntity blockEntity) {
             CompoundTag compoundTag = blockEntity.getUpdateTag();
             BlockPos blockPos = blockEntity.getBlockPos();
+            MetaApiAccessor.filterTileEntityMeta(compoundTag); // PaperDragon
             int i = SectionPos.sectionRelative(blockPos.getX()) << 4 | SectionPos.sectionRelative(blockPos.getZ());
             blockEntity.sanitizeSentNbt(compoundTag); // Paper - Sanitize sent data
             return new ClientboundLevelChunkPacketData.BlockEntityInfo(i, blockPos.getY(), blockEntity.getType(), compoundTag.isEmpty() ? null : compoundTag);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 6fa47becd0f83ac4273ef3a10c314aa27b08184b..19e266364d9922d312d74e505261fc49994ee5e9 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1,5 +1,8 @@
 package net.minecraft.world.entity;
 
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
+import com.domnian.paperdragon.api.meta.PersistentMetaMap; // PaperDragon
+import com.domnian.paperdragon.api.meta.TempMetaMap; // PaperDragon
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Iterables;
@@ -156,6 +159,10 @@ import org.bukkit.plugin.PluginManager;
 
 public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
+    // PaperDragon start
+    public final PersistentMetaMap metaMap = new PersistentMetaMap();
+    public final TempMetaMap tempMeta = new TempMetaMap();
+    // PaperDragon end
     // CraftBukkit start
     private static final int CURRENT_LEVEL = 2;
     public boolean preserveMotion = true; // Paper - keep initial motion on first setPositionRotation
@@ -2139,6 +2146,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
             // CraftBukkit start - Checking for NaN pitch/yaw and resetting to zero
             // TODO: make sure this is the best way to address this.
+            MetaApiAccessor.saveEntityMeta(this, nbt); // PaperDragon
             if (Float.isNaN(this.yRot)) {
                 this.yRot = 0;
             }
@@ -2395,6 +2403,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             }
             // CraftBukkit end
 
+            MetaApiAccessor.loadEntityMeta(this, nbt); // PaperDragon
             // Paper start - Restore the entity's origin location
             ListTag originTag = nbt.getList("Paper.Origin", 6);
             if (!originTag.isEmpty()) {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 0c46234ac6e2e33f458b9c7467cb626e043e3e43..fe464ee0157d3f15c1616780e940ff7e81fdddca 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -4,6 +4,7 @@ import co.aikar.timings.Timing;
 import co.aikar.timings.Timings;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
@@ -597,6 +598,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                     this.onBlockStateChange(blockposition, iblockdata1, iblockdata2);
                 }
                 */
+                if (block == Blocks.AIR) MetaApiAccessor.processSetAir(chunk, pos); // PaperDragon
 
                 // CraftBukkit start
                 if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index b96d57b0bcf21508f8e03e96b7553eb486fdf212..61911ed1309bd7c6ce32b2b2a2e6bab555fd6d29 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -2,6 +2,9 @@ package net.minecraft.world.level.block.entity;
 
 import com.mojang.logging.LogUtils;
 import javax.annotation.Nullable;
+
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
+import com.domnian.paperdragon.api.meta.PersistentMetaMap; // PaperDragon
 import net.minecraft.CrashReportCategory;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
@@ -28,6 +31,7 @@ import co.aikar.timings.Timing; // Paper
 public abstract class BlockEntity {
     static boolean IGNORE_TILE_UPDATES = false; // Paper
 
+    public final com.domnian.paperdragon.api.meta.PersistentMetaMap metaMap = new PersistentMetaMap(); // PaperDragon
     public Timing tickTimer = MinecraftTimings.getTileEntityTimings(this); // Paper
     // CraftBukkit start - data containers
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
@@ -68,6 +72,7 @@ public abstract class BlockEntity {
 
     // CraftBukkit start - read container
     public void load(CompoundTag nbt) {
+        MetaApiAccessor.loadTileEntityMeta(this, nbt); // PaperDragon
         this.persistentDataContainer.clear(); // Paper - clear instead of init
 
         net.minecraft.nbt.Tag persistentDataTag = nbt.get("PublicBukkitValues");
@@ -125,6 +130,7 @@ public abstract class BlockEntity {
 
     private void saveMetadata(CompoundTag nbt) {
         this.saveId(nbt);
+        MetaApiAccessor.saveTileEntityMeta(this, nbt); // PaperDragon
         nbt.putInt("x", this.worldPosition.getX());
         nbt.putInt("y", this.worldPosition.getY());
         nbt.putInt("z", this.worldPosition.getZ());
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 7350b73f4af4ae347532dc579ab151447c298e09..8164a575288ebcf95018610e9858188f487b833e 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -1,5 +1,8 @@
 package net.minecraft.world.level.chunk;
 
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
+import com.domnian.paperdragon.api.meta.PersistentMetaMap; // PaperDragon
+import com.domnian.paperdragon.api.meta.TempMetaMap; // PaperDragon
 import com.google.common.collect.ImmutableList;
 import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.collect.Maps;
@@ -55,6 +58,12 @@ import net.minecraft.world.ticks.TickContainerAccess;
 import org.slf4j.Logger;
 
 public class LevelChunk extends ChunkAccess {
+    // PaperDragon start
+    public MetaApiAccessor.BlockPersistentMeta blockMeta = new MetaApiAccessor.BlockPersistentMeta();
+    public PersistentMetaMap chunkMeta = new PersistentMetaMap();
+    public MetaApiAccessor.BlockTempMeta blockTempMeta = new MetaApiAccessor.BlockTempMeta();
+    public TempMetaMap chunkTempMeta = new TempMetaMap();
+    // PaperDragon end
 
     static final Logger LOGGER = LogUtils.getLogger();
     private static final TickingBlockEntity NULL_TICKER = new TickingBlockEntity() {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index 13b62e8e6569c154547bc0d5626488c5b0839f20..a5ac36169b4624026eecade5cf18748904f05030 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -14,6 +14,7 @@ import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag; // PaperDragon
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.LevelHeightAccessor;
@@ -48,6 +49,12 @@ public class ProtoChunk extends ChunkAccess {
     private BelowZeroRetrogen belowZeroRetrogen;
     private final ProtoChunkTicks<Block> blockTicks;
     private final ProtoChunkTicks<Fluid> fluidTicks;
+    // PaperDragon start
+    public @Nullable CompoundTag legacyChunkMeta;
+    public @Nullable ListTag legacyChunkMetaList;
+    public @Nullable CompoundTag chunkMeta;
+    public @Nullable ListTag blockMetaList;
+    // PaperDragon end
 
     public ProtoChunk(ChunkPos pos, UpgradeData upgradeData, LevelHeightAccessor world, Registry<Biome> biomeRegistry, @Nullable BlendingData blendingData) {
         this(pos, upgradeData, (LevelChunkSection[])null, new ProtoChunkTicks<>(), new ProtoChunkTicks<>(), world, biomeRegistry, blendingData);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
index 34e351e04ac57e47e3cea671c61cc01d17983b77..226120f51cbc2d272ac694a1f52e8d80ddf4f4c5 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.level.chunk.storage;
 
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
 import com.google.common.collect.Maps;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
@@ -379,6 +380,7 @@ public class ChunkSerializer {
         }
 
         Heightmap.primeHeightmaps((ChunkAccess) object1, enumset);
+        MetaApiAccessor.loadChunkMetaNbt(nbt, (ChunkAccess) object1); // PaperDragon
         CompoundTag nbttagcompound3 = nbt.getCompound("structures");
 
         ((ChunkAccess) object1).setAllStarts(ChunkSerializer.unpackStructureStart(StructurePieceSerializationContext.fromLevel(world), nbttagcompound3, world.getSeed()));
@@ -509,6 +511,7 @@ public class ChunkSerializer {
         nbttagcompound.putInt("xPos", chunkcoordintpair.x);
         nbttagcompound.putInt("yPos", chunk.getMinSection());
         nbttagcompound.putInt("zPos", chunkcoordintpair.z);
+        MetaApiAccessor.saveChunkMetaNbt(nbttagcompound, chunk); // PaperDragon
         nbttagcompound.putLong("LastUpdate", asyncsavedata != null ? asyncsavedata.worldTime : world.getGameTime()); // Paper - async chunk unloading // Paper - diff on change
         nbttagcompound.putLong("InhabitedTime", chunk.getInhabitedTime());
         nbttagcompound.putString("Status", chunk.getStatus().getName());
diff --git a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
index 69fb994ae11f0ea8ad5de8861477fcb25529f7ab..8c96654da5be94c0b0cbd2a4528285731f94f9f7 100644
--- a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
+++ b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.level.storage;
 
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
 import com.google.common.collect.UnmodifiableIterator;
@@ -244,6 +245,7 @@ public class LevelStorageSource {
                 // CraftBukkit start - Add PDC to world
                 PrimaryLevelData worldDataServer = PrimaryLevelData.parse(dynamic, datafixer, i, nbttagcompound2, worldsettings, levelversion, (WorldGenSettings) pair.getFirst(), lifecycle1);
                 worldDataServer.pdc = nbttagcompound1.get("BukkitValues");
+                MetaApiAccessor.loadWorldMeta(worldDataServer, nbttagcompound1); // PaperDragon
                 return worldDataServer;
                 // CraftBukkit end
             } catch (Exception exception) {
diff --git a/src/main/java/net/minecraft/world/level/storage/PrimaryLevelData.java b/src/main/java/net/minecraft/world/level/storage/PrimaryLevelData.java
index e537a8df45c31efa80cb898cbef9c3a09fac3bf9..b5d83a4c98cee52def3c1c8b8f6a6a1c5c195969 100644
--- a/src/main/java/net/minecraft/world/level/storage/PrimaryLevelData.java
+++ b/src/main/java/net/minecraft/world/level/storage/PrimaryLevelData.java
@@ -1,5 +1,8 @@
 package net.minecraft.world.level.storage;
 
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
+import com.domnian.paperdragon.api.meta.PersistentMetaMap; // PaperDragon
+import com.domnian.paperdragon.api.meta.TempMetaMap; // PaperDragon
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
@@ -50,6 +53,10 @@ import org.bukkit.event.weather.WeatherChangeEvent;
 // CraftBukkit end
 
 public class PrimaryLevelData implements ServerLevelData, WorldData {
+    // PaperDragon start
+    public final PersistentMetaMap metaMap = new PersistentMetaMap();
+    public final TempMetaMap tempMetaMap = new TempMetaMap();
+    // PaperDragon end
 
     private static final Logger LOGGER = LogUtils.getLogger();
     protected static final String PLAYER = "Player";
@@ -232,6 +239,7 @@ public class PrimaryLevelData implements ServerLevelData, WorldData {
             levelNbt.putUUID("WanderingTraderId", this.wanderingTraderId);
         }
 
+        MetaApiAccessor.saveWorldMeta(this, levelNbt); // PaperDragon
         levelNbt.putString("Bukkit.Version", Bukkit.getName() + "/" + Bukkit.getVersion() + "/" + Bukkit.getBukkitVersion()); // CraftBukkit
         this.world.getWorld().storeBukkitValues(levelNbt); // CraftBukkit - add pdc
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 75c6b0aa2cb4ae8637460006ff24d7f6028396be..2eea871ca19b1abf9ea8a83529dc89849c6a6647 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -1,5 +1,7 @@
 package org.bukkit.craftbukkit;
 
+import com.domnian.paperdragon.api.meta.PersistentMetaMap; // PaperDragon
+import com.domnian.paperdragon.api.meta.TempMetaMap; // PaperDragon
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.mojang.serialization.Codec;
@@ -48,8 +50,19 @@ import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.entity.Entity;
 import org.bukkit.persistence.PersistentDataContainer;
 import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull; // PaperDragon
 
 public class CraftChunk implements Chunk {
+    // PaperDragon start
+    @NotNull
+    public PersistentMetaMap getPersistentMeta() {
+        return getHandle().chunkMeta;
+    }
+    @NotNull
+    public TempMetaMap getTempMeta() {
+        return getHandle().chunkTempMeta;
+    }
+    // PaperDragon end
     private WeakReference<net.minecraft.world.level.chunk.LevelChunk> weakChunk;
     private final ServerLevel worldServer;
     private final int x;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 34621a9b3572fb70305a5405fd21378c21392f0b..588f2688737c313ec55eb4567fe168f2139133d3 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit;
 
+import com.domnian.paperdragon.api.meta.MetaApiAccessor; // PaperDragon
 import com.google.common.base.Charsets;
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
@@ -1024,6 +1025,7 @@ public final class CraftServer implements Server {
             ));
             if (console.isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper
         }
+        MetaApiAccessor.reload(); // PaperDragon
         this.loadPlugins();
         this.enablePlugins(PluginLoadOrder.STARTUP);
         this.enablePlugins(PluginLoadOrder.POSTWORLD);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 55d83a9a691d11c9408d2c3260c3e77dfb51b97e..8d6f46a50796fe1936a263c78fc69dcb012e0769 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -1,5 +1,7 @@
 package org.bukkit.craftbukkit;
 
+import com.domnian.paperdragon.api.meta.PersistentMetaMap; // PaperDragon
+import com.domnian.paperdragon.api.meta.TempMetaMap; // PaperDragon
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
@@ -135,8 +137,19 @@ import org.bukkit.util.Consumer;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.StructureSearchResult;
 import org.bukkit.util.Vector;
+import org.jetbrains.annotations.NotNull; // PaperDragon
 
 public class CraftWorld extends CraftRegionAccessor implements World {
+    // PaperDragon start
+    @NotNull
+    public PersistentMetaMap getPersistentMeta() {
+        return getHandle().serverLevelData.metaMap;
+    }
+    @NotNull
+    public TempMetaMap getTempMeta() {
+        return getHandle().serverLevelData.tempMetaMap;
+    }
+    // PaperDragon end
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
     private static final ChunkStatus[] REGEN_CHUNK_STATUSES = {ChunkStatus.BIOMES, ChunkStatus.NOISE, ChunkStatus.SURFACE, ChunkStatus.CARVERS, ChunkStatus.LIQUID_CARVERS, ChunkStatus.FEATURES}; // Paper - implement regenerate chunk method
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
index a2894f02ceb7c58f6eafe055e1ff47b197b100f2..52a0331f2719face651d48b9576240bd7a300c35 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
@@ -132,4 +132,10 @@ public abstract class CraftBlockEntityState<T extends BlockEntity> extends Craft
         return !this.snapshotDisabled;
     }
     // Paper end
+    // PaperDragon start
+    @Override
+    public boolean isTileEntity() {
+        return tileEntity != null;
+    }
+    // PaperDragon end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index a8ab1d3ee81664193be39d2735d6495136e0e310..8e1776b33b5f76c21f8efbfae0de8d9010f5179a 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -359,4 +359,10 @@ public class CraftBlockState implements BlockState {
         }
     }
     // Paper end
+    // PaperDragon start
+    @Override
+    public boolean isTileEntity() {
+        return false;
+    }
+    // PaperDragon end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 9368ec01e498f913bc5b7b3e77fe87659090d9b5..f17de9f0c145ee65224f3a09aa1e7652f3a820d3 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1,5 +1,7 @@
 package org.bukkit.craftbukkit.entity;
 
+import com.domnian.paperdragon.api.meta.PersistentMetaMap; // PaperDragon
+import com.domnian.paperdragon.api.meta.TempMetaMap; // PaperDragon
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
@@ -189,8 +191,17 @@ import org.bukkit.plugin.Plugin;
 import org.bukkit.util.BoundingBox;
 import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
+import org.jetbrains.annotations.NotNull; // PaperDragon
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
+    // PaperDragon start
+    public @NotNull PersistentMetaMap getPersistentMeta() {
+        return getHandle().metaMap;
+    }
+    public @NotNull TempMetaMap getTempMeta() {
+        return getHandle().tempMeta;
+    }
+    // PaperDragon end
     private static PermissibleBase perm;
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
 
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 03b3f29bde2bf6cb4e7b08a775bcc380a9404543..58a5013344b62c2dc959084278df4e22ac46d08b 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -1533,6 +1533,11 @@ public class CraftEventFactory {
         InventoryCloseEvent event = new InventoryCloseEvent(human.containerMenu.getBukkitView(), reason); // Paper
         human.level.getCraftServer().getPluginManager().callEvent(event);
         human.containerMenu.transferTo(human.inventoryMenu, human.getBukkitEntity());
+        // PaperDragon start
+        if (event.getInventory().getViewers().isEmpty()) {
+            org.bukkit.craftbukkit.inventory.CraftInventory.meta.remove(((org.bukkit.craftbukkit.inventory.CraftInventory) event.getInventory()).getInventory());
+        }
+        // PaperDragon end
     }
 
     public static ItemStack handleEditBookEvent(ServerPlayer player, int itemInHandIndex, ItemStack itemInHand, ItemStack newBookItem) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
index 30ac442049088200e9ab77a561c59cbc58aaa28f..8633f1b0c6c0fe06e7c7cf9109f3045b71b7b0b2 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
@@ -29,6 +29,12 @@ import org.bukkit.inventory.InventoryHolder;
 import org.bukkit.inventory.ItemStack;
 
 public class CraftInventory implements Inventory {
+    // PaperDragon start
+    public static final java.util.WeakHashMap<Container, HashMap<String, Object>> meta = new java.util.WeakHashMap<>(64);
+    public HashMap<String, Object> getMeta() {
+        return meta.computeIfAbsent(inventory, k -> new HashMap<>());
+    }
+    // PaperDragon end
     protected final Container inventory;
 
     public CraftInventory(Container inventory) {
